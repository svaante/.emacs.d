* Basic stuff to get some type of order
  #+BEGIN_SRC emacs-lisp
;; remove gui elements
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1) 
;; remove visual bell
(setq visible-bell       nil
      ring-bell-function #'ignore)

;; set default dir to home
(setq default-directory "~/")

;; follow symlinks
(setq vc-follow-symlinks t)

;; spaces not tabs
(setq-default indent-tabs-mode nil)
(setq indent-line-function 'insert-tab)

;; no backup files
(setq make-backup-files nil)
(global-auto-revert-mode t)

;; y/n will do
(fset 'yes-or-no-p 'y-or-n-p)

;; stop the insessent blinking
(blink-cursor-mode 0)

;; Truncate that shit
(use-package simple
  :diminish visual-line-mode)

;; Backup trails is worse then chem-trails, losing patches is 99% of the time my fault
(setq auto-save-default nil)

;; Back to basic on extremely long lines 
(global-so-long-mode 1)

(set-frame-font "Hack-12" nil t) ;; Set font
(set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji" :size 9) nil 'prepend) ;; I want my flower

  #+END_SRC

* Theming
  #+BEGIN_SRC emacs-lisp
  ;(use-package acme-theme
  ;  :ensure t
  ;  :defer t
  ;  :init
  ;  (custom-set-faces '(linum-relative-current-face
  ;                    ((t :inherit linum :foreground "grey" :weight bold))))
  ;  (load-theme 'acme t))

  (use-package emacs
    :ensure t
    :defer t
    :init
     (custom-set-faces '(linum-relative-current-face
                     ((t :inherit linum :foreground "white" :weight bold))))
    (load-theme 'modus-vivendi t)
    )

  (use-package emacs
    :config
    (setq mode-line-percent-position '(-3 "%p"))
    (setq mode-line-defining-kbd-macro
          (propertize " Macro" 'face 'mode-line-emphasis))
    (setq-default mode-line-format
                  '("ðŸŒ»"
                    "%e"
                    ""
                    mode-line-front-space
                    mode-line-mule-info
                    mode-line-client
                    mode-line-modified
                    mode-line-remote
                    mode-line-frame-identification
                    mode-line-buffer-identification
                    " "
                    mode-line-position
                    (vc-mode vc-mode)
                    " "
                    mode-line-modes
                    " "
                    mode-line-misc-info
                    mode-line-end-spaces))
    :init
    (column-number-mode 1))

  (use-package exec-path-from-shell
    :ensure t
    :config
    (exec-path-from-shell-initialize))

  #+END_SRC

* Save my mode-line
  #+begin_src emacs-lisp
(use-package diminish
  :ensure
  :after use-package)

  (use-package undo-tree
  :diminish)
  #+end_src

* Package dashboard
  #+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :diminish
    :ensure t
    :config
    (setq dashboard-items '((recents  . 10)
                            (bookmarks . 10)))
    (dashboard-setup-startup-hook))
  #+END_SRC

* Mac stuff
  #+BEGIN_SRC  emacs-lisp
(if (eq system-type 'darwin)
  (progn
    (setq mac-option-key-is-meta t)
    (setq mac-right-option-modifier nil)
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    (add-to-list 'default-frame-alist '(ns-appearance . light))))
  #+END_SRC

* Relative line numbers
  #+BEGIN_SRC emacs-lisp
  (use-package linum
    :diminish
    :ensure t
    :init
    (add-hook 'prog-mode-hook 'linum-mode))

  (use-package linum-relative
    :diminish
    :ensure t
    :init
    (setq linum-relative-current-symbol "")
    (add-hook 'prog-mode-hook 'linum-relative-mode))
  #+END_SRC

* Global mappings
  #+begin_src emacs-lisp
  (defun +emacs/switch-to-next-buffer ()
    "Switch to next buffer but stop at last buffer"
    (interactive)
    (when (window-next-buffers)
      (switch-to-next-buffer)))

  (defun +emacs/switch-to-prev-buffer ()
    "Switch to prev buffer but stop at last buffer"
    (interactive)
    (when (window-prev-buffers)
      (switch-to-prev-buffer)))

  (defun +emacs/jump-or-jump (this-jump-fn that-jump-fn)
    "Change buffer and/or cursor position with this-fn or that-fn"
    (interactive)
    (let* ((p (point)))
      (funcall this-jump-fn)
      (when (= p (point))
        (funcall that-jump-fn))))

  (defun +emacs/evil-jump-forward-or-next-buffer ()
    "Jump forward or goto next buffer if there is no prev jump in buffer"
    (interactive)
    (+emacs/jump-or-jump (lambda () (evil--jump-forward 1))
                         '+emacs/switch-to-next-buffer))

  (defun +emacs/evil-jump-backward-or-prev-buffer ()
    "Jump backward or goto prev buffer if there is no prev jump in buffer"
    (interactive)
    (+emacs/jump-or-jump (lambda () (evil--jump-backward 1))
                         '+emacs/switch-to-prev-buffer))


  (defun +emacs/key-bindings ()
    (progn
      (define-key evil-normal-state-map "\C-j" 'evil-window-down)
      (define-key evil-normal-state-map "\C-k" 'evil-window-up)
      (define-key evil-normal-state-map "\C-h" 'evil-window-left)
      (define-key evil-normal-state-map "\C-l" 'evil-window-right)
      (define-key evil-insert-state-map "\C-j" 'evil-window-down)
      (define-key evil-insert-state-map "\C-k" 'evil-window-up)
      (define-key evil-insert-state-map "\C-h" 'evil-window-left)
      (define-key evil-insert-state-map "\C-l" 'evil-window-right)
      (define-key evil-normal-state-map (kbd "C-i") #'+emacs/evil-jump-forward-or-next-buffer)
      (define-key evil-normal-state-map (kbd "C-o") #'+emacs/evil-jump-backward-or-prev-buffer)))
  #+end_src
    
* Evil
  Evil config
  #+BEGIN_SRC emacs-lisp
    (defun +emacs/split-follow-window-vertically ()
      "Split and follow window vertically"
      (interactive)
      (split-window-vertically) (other-window 1))

    (defun +emacs/split-follow-window-horizontally ()
      "Split and follow window horizontally"
      (interactive)
      (split-window-horizontally) (other-window 1))

    (use-package evil
      :ensure evil
      :init
      (setq evil-want-integration t)
      (setq evil-want-keybinding nil)
      (setq-default evil-symbol-word-search t)
      (setq-default evil-shift-width 2)
      (setq evil-jumps-cross-buffers nil)
      (setq evil-want-Y-yank-to-eol t)
      (setq evil-want-C-u-scroll t)
      (setq evil-search-module 'evil-search)
      :config
      (+emacs/key-bindings)
      (define-key evil-normal-state-map "\C-ws" #'+emacs/split-follow-window-vertically)
      (define-key evil-normal-state-map "\C-wv" #'+emacs/split-follow-window-horizontally)

      (evil-define-key 'normal 'global
        ;; select the previously pasted text
        "gp" "`[v`]"
        ;; run the macro in the q register
        "Q" "@q")

      (defalias #'forward-evil-word #'forward-evil-symbol)
      (evil-ex-define-cmd "E[dit]" 'evil-edit)
      (evil-ex-define-cmd "W[rite]" 'evil-write)
      (evil-ex-define-cmd "Wq" 'evil-save-and-close)
      (evil-ex-define-cmd "WQ" 'evil-save-and-close)
      (evil-ex-define-cmd "Wq" 'evil-save-and-close)
      (evil-ex-define-cmd "Qa[ll]" "quitall")
      (evil-ex-define-cmd "qA[ll]" "quitall")
      (evil-ex-define-cmd "QA[ll]" "quitall")

      (setq evil--jumps-buffer-targets "\\*\\(new\\|scratch\\|eshell: .*\\)\\*")

      (evil-mode 1)

    (use-package evil-escape
      :diminish
      :ensure t
      :init
      (setq evil-escape-delay 0.2)
      (setq evil-escape-unordered-key-sequence t)
      (setq-default evil-escape-key-sequence "jk")
      :config
      (evil-escape-mode))


    (use-package evil-collection
      :after evil
      :ensure t
      :config
      (setq evil-collection-mode-list (remove 'eshell evil-collection-mode-list))
      (evil-collection-init)))

  #+END_SRC

* Leader mappings
  #+BEGIN_SRC emacs-lisp
    (use-package evil-leader
      :ensure t
      :config
      (setq evil-leader/in-all-states 1)
      (global-evil-leader-mode)
      (evil-leader/set-leader "<SPC>")
      (evil-leader/set-key "." 'counsel-find-file
                           "hh" 'counsel-describe-function
                           "hb" 'counsel-descbinds
                           "hv" 'counsel-describe-variable
                           "b" 'counsel-switch-buffer
                           "y" 'counsel-yank-pop
                           "i" 'ibuffer
                           "t" 'vterm
                           ":" 'counsel-M-x
                           "r" (lambda () (load-file user-init-file))
                           "wt" (lambda () (interactive) (toggle-frame-maximized))
                           "p!" 'projectile-run-async-shell-command-in-root
                           "on" (lambda () (interactive) (find-file "~/org/notes.org"))
                           "pt" '+emacs/org-projectile-goto-location-for-project))
      #+END_SRC 

* Org 
  #+BEGIN_SRC emacs-lisp
  (use-package org-agenda
    :config
    (evil-leader/set-key "oa" 'org-agenda)
    (eval-after-load 'org-agenda
      '(progn
         (setq org-agenda-files '("~/org/todo.org"))
         (evil-set-initial-state 'org-agenda-mode 'normal)
         (evil-define-key 'normal org-agenda-mode-map
           (kbd "<RET>") 'org-agenda-switch-to
           (kbd "\t") 'org-agenda-goto
           "q" 'org-agenda-quit
           "r" 'org-agenda-redo
           "S" 'org-save-all-org-buffers
           "gj" 'org-agenda-goto-date
           "gJ" 'org-agenda-clock-goto
           "gm" 'org-agenda-bulk-mark
           "go" 'org-agenda-open-link
           "s" 'org-agenda-schedule
           "+" 'org-agenda-priority-up
           "," 'org-agenda-priority
           "-" 'org-agenda-priority-down
           "y" 'org-agenda-todo-yesterday
           "n" 'org-agenda-add-note
           "t" 'org-agenda-todo
           ":" 'org-agenda-set-tags
           ";" 'org-timer-set-timer
           "I" 'helm-org-task-file-headings
           "i" 'org-agenda-clock-in-avy
           "O" 'org-agenda-clock-out-avy
           "u" 'org-agenda-bulk-unmark
           "x" 'org-agenda-exit
           "j"  'org-agenda-next-line
           "k"  'org-agenda-previous-line
           "vt" 'org-agenda-toggle-time-grid
           "va" 'org-agenda-archives-mode
           "vw" 'org-agenda-week-view
           "vl" 'org-agenda-log-mode
           "vd" 'org-agenda-day-view
           "vc" 'org-agenda-show-clocking-issues
           "g/" 'org-agenda-filter-by-tag
           "o" 'delete-other-windows
           "gh" 'org-agenda-holiday
           "gv" 'org-agenda-view-mode-dispatch
           "f" 'org-agenda-later
           "b" 'org-agenda-earlier
           "c" 'helm-org-capture-templates
           "e" 'org-agenda-set-effort
           "n" nil  ; evil-search-next
           "{" 'org-agenda-manipulate-query-add-re
           "}" 'org-agenda-manipulate-query-subtract-re
           "A" 'org-agenda-toggle-archive-tag
           "." 'org-agenda-goto-today
           "0" 'evil-digit-argument-or-evil-beginning-of-line
           "<" 'org-agenda-filter-by-category
           ">" 'org-agenda-date-prompt
           "F" 'org-agenda-follow-mode
           "D" 'org-agenda-deadline
           "H" 'org-agenda-holidays
           "J" 'org-agenda-next-date-line
           "K" 'org-agenda-previous-date-line
           "L" 'org-agenda-recenter
           "P" 'org-agenda-show-priority
           "R" 'org-agenda-clockreport-mode
           "Z" 'org-agenda-sunrise-sunset
           "T" 'org-agenda-show-tags
           "X" 'org-agenda-clock-cancel
           "[" 'org-agenda-manipulate-query-add
           "g\\" 'org-agenda-filter-by-tag-refine
           "]" 'org-agenda-manipulate-query-subtract))))

  (use-package org-capture
    :init
    (setq org-capture-templates '(("t" "Task Entry" entry
                                   (file+headline "~/org/todo.org" "Tasks")
                                   "* %?\n  %t\n")
                                  ("r" "Remember Entry" entry
                                   (file+headline "~/org/todo.org" "Remember")
                                   "* %?\n  %(org-insert-time-stamp (org-read-date nil t \"+1d\"))\n")))
    :config

    (evil-leader/set-key "oc" 'counsel-org-capture)

    (add-hook 'org-capture-mode-hook 'evil-insert-state))

  (use-package org
    :init 
    :config
    (defun org-mode-configuration ()
      (with-eval-after-load 'evil-collection
        (+emacs/key-bindings)))

    (add-hook 'org-mode-hook 'org-mode-configuration))

  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

  #+END_SRC

* Hyperbole
  #+begin_src  emacs-lisp
  (use-package hyperbole
    :diminish
    :ensure t)
  #+end_src

* Package company
  Use company for packages

  #+BEGIN_SRC emacs-lisp

    (use-package company
       :diminish company-mode
       :ensure t
       ;; Use Company for completion
       :init (global-company-mode 1)
       :config
       ;(setq tab-always-indent 'complete)
       ;;; some better default values
       ;(setq company-idle-delay 0.1)
       (setq company-minimum-prefix-length 5)
       ;(setq company-tooltip-align-annotations t)
       ;(setq company-selection-wrap-around t)
       (setq company-backends '(company-capf
                                company-files))

       ;(setq company-global-modes '(not eshell-mode))

       ;;; align annotations in tooltip
       ;(setq company-tooltip-align-annotations t)
       ;(setq company-dabbrev-downcase nil)
       ;(setq company-require-match 'never)

       ;;; nicer keybindings
       ;(define-key company-active-map (kbd "C-n") 'company-select-next)
       ;(define-key company-active-map (kbd "C-p") 'company-select-previous)
       ;(define-key company-active-map (kbd "K") 'company-show-doc-buffer)
)

       ;(use-package company-posframe
       ;  :diminish
       ;  :ensure t
       ;  :config
       ;  (setq company-posframe-show-metadata nil)
       ;  (setq company-posframe-show-indicator nil)
       ;  (setq company-posframe-quickhelp-delay nil)
       ;  (company-posframe-mode +1))
  #+END_SRC

* Package counsel
  #+BEGIN_SRC emacs-lisp
      ;(use-package ivy-rich
      ;  :diminish
      ;  :ensure t
      ;  :after ivy
      ;  :custom
      ;  (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
      ;  (ivy-rich-mode 1))

      ;(use-package ivy-posframe
      ;  :diminish
      ;  :ensure t
      ;  :custom
      ;  (ivy-posframe-style 'frame-center)
      ;  (ivy-posframe-display-functions-alist
      ;  '((swiper . ivy-posframe-display-at-window-bottom-left)
      ;    (t . ivy-posframe-display)))
      ;  :config
      ;  (ivy-posframe-mode))

      (use-package ivy
        :diminish
        :hook (after-init . ivy-mode)
        :config
        (setq ivy-wrap t)
        (setq ivy-height 15)
        (setq ivy-display-style nil)
        (setq ivy-re-builders-alist
              '((counsel-rg            . ivy--regex-plus)
                (counsel-projectile-rg . ivy--regex-plus)
                (swiper                . ivy--regex-plus)
                (t                     . ivy--regex-fuzzy)))
        (setq ivy-use-virtual-buffers t)
        (setq ivy-count-format "(%d/%d) ")
        (setq ivy-initial-inputs-alist nil)

        (define-key ivy-minibuffer-map (kbd "C-SPC") 'ivy-dispatching-done))

      (use-package swiper
        :ensure t
        :config
        (evil-leader/set-key "s" 'swiper))

      (use-package counsel
        :ensure t
        :config
        (setq counsel-ag-base-command "ag --nocolor --nogroup --smart-case --column %s")

        (defun +ivy/projectile-find-file ()
          (interactive)
          (let ((this-command 'counsel-find-file))
            (call-interactively
             (if (or (file-equal-p default-directory "~")
                     (file-equal-p default-directory "/"))
                 #'counsel-find-file
               (let ((files (projectile-current-project-files)))
                 (if (<= (length files) ivy-sort-max-size)
                     #'counsel-projectile-find-file
                   #'projectile-find-file))))))

        (setq counsel-find-file-at-point t)

        (evil-leader/set-key "SPC" '+ivy/projectile-find-file
                              "." 'counsel-find-file))

      (use-package prescient
        :ensure t
        :config
        (progn
          (use-package ivy-prescient
            :ensure t
            :config
            (ivy-prescient-mode))
          (prescient-persist-mode)))

  #+END_SRC

* Dired stuff
  #+begin_src emacs-lisp
(use-package dired-subtree
  :ensure t
  :after dired
  :bind (:map dired-mode-map
              ("TAB" . dired-subtree-toggle)))

  #+end_src

* LSP 
  #+begin_src emacs-lisp
        (use-package lsp-mode
          :ensure t
          :hook (prog-mode . (lambda ()
                               (unless (derived-mode-p 'emacs-lisp-mode 'lisp-mode)
                                 (lsp-deferred))))
          :config
          (setq lsp-prefer-flymake nil)
          (defun lsp-mode-configuration ()
            (with-eval-after-load 'evil
              (define-key evil-normal-state-local-map "K" 'lsp-describe-thing-at-point)
              (define-key evil-normal-state-local-map "gd" 'lsp-find-definition)
              (define-key evil-normal-state-local-map "gr" 'lsp-find-references)))
          (setq lsp-file-watch-threshold 2000)
          (setq read-process-output-max (* 1024 1024))
          (add-hook 'lsp-mode-hook 'lsp-mode-configuration))

        (use-package flycheck
          :ensure t
          :init (add-hook 'prog-mode-hook 'flycheck-mode)
          :config

          (setq-default flycheck-disabled-checkers
                        (append flycheck-disabled-checkers
                                '(javascript-jshint json-jsonlist)))

          (defun codefalling//reset-eslint-rc ()
            (let ((rc-path (if (projectile-project-p)
                               (concat (projectile-project-root) ".eslintrc"))))
              (if (file-exists-p rc-path)
                  (progn
                    (message rc-path)
                    (setq flycheck-eslintrc rc-path)))))

          (flycheck-add-mode 'javascript-eslint 'js-mode)
          (add-hook 'flycheck-mode-hook 'codefalling//reset-eslint-rc)
          (add-hook 'flycheck-mode-hook 'add-node-modules-path))
  #+end_src

* WD management
  #+begin_src emacs-lisp 
        (use-package projectile
          :ensure t
          :config
          (projectile-mode +1))
    projectile-project-root-files #'( ".projectile" )
    projectile-project-root-files-functions #'(projectile-root-top-down
                                               projectile-root-top-down-recurring
                                               projectile-root-bottom-up
                                               projectile-root-local)

        (use-package counsel-projectile
          :diminish
          :ensure t
          :config
          (setcar counsel-projectile-switch-project-action 4)
          (evil-leader/set-key
            "pp" 'counsel-projectile-switch-project
            "pi" 'projectile-invalidate-cache
            "pt" 'projectile-test-project
            "pg" 'projectile-ripgrep)

          (counsel-projectile-mode))

    (use-package org-projectile
      :ensure t
      :config
      (setq org-projectile:projects-file "/Users/svaante/projects.org")
      (setq org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
      (push (org-projectile-project-todo-entry) org-capture-templates)

      (defun +emacs/org-projectile-goto-location-for-project ()
        (interactive)
        (let* ((context (make-instance 'occ-context
                                       :category (projectile-project-name)
                                       :template org-projectile-capture-template
                                       :strategy org-projectile-strategy
                                       :options nil))
               (marker (occ-get-capture-marker context))
               (buf (marker-buffer marker)))
          ;(switch-to-buffer (other-buffer buf))
          (switch-to-buffer-other-window buf)
          (goto-char (marker-position marker))))

      (evil-leader/set-key
        "pn" 'org-projectile-capture-for-current-project))
  #+end_src

* Terminal
  #+begin_src  emacs-lisp
  (use-package vterm :ensure t)
  #+end_src

  #+begin_src emacs-lisp
    (use-package eshell
      :ensure t
      :config

      (setenv "PAGER" "cat")

      (defun eshell-cwd-rename (&optional i)
        "Renames eshell buffer to *eshell: <cwd> <number of buffers with this name>*"
        (interactive)
        (unless i (setq i 0))
        (let* ((buffer-cwd (if (buffer-file-name)
                               (file-name-directory (buffer-file-name))
                               default-directory))
               (name (car (last (split-string buffer-cwd "/" t))))
               (b-name (if (zerop i)
                           (concat "*eshell: " name "*")
                           (concat "*eshell: " name " " (number-to-string i) "*"))))
          (cond ((string= (buffer-name) b-name) nil)
                ((null (get-buffer b-name)) (rename-buffer b-name))
                (t (eshell-cwd-rename (1+ i))))))

      (defun eshell-here ()
        "Opens up a new shell in the directory associated with the current buffer's file."
        (interactive)
        (let* ((parent (if (buffer-file-name)
                           (file-name-directory (buffer-file-name))
                         default-directory))
               (name (car (last (split-string parent "/" t))))
               (b-name (concat "*eshell: " name "*")))
          (if (null (get-buffer b-name))
              (let ((buf (eshell "new")))
                (switch-to-buffer (other-buffer buf))
                (switch-to-buffer-other-window buf)
                (rename-buffer b-name))
            (switch-to-buffer-other-window (get-buffer b-name)))))

      (defun eshell-project-root ()
        (interactive)
        (let ((buf (projectile-run-eshell 1)))
          (switch-to-buffer (other-buffer buf))
          (switch-to-buffer-other-window buf)))

      (evil-leader/set-key "e" 'eshell-here
        "pe" 'eshell-project-root)

      (defun +eshell/goto-end-of-prompt ()
        "Move cursor to the prompt when switching to insert mode (if point isn't
                already there)."
        (interactive)
        (goto-char (point-max))
        (evil-append 1))

      (defun +eshell/counsel-esh-history-normal ()
        "Move cursor to the end of the buffer before calling counsel-esh-history
                  and change `state` to insert"
        (interactive)
        (goto-char (point-max))
        (evil-insert 0)
        (counsel-esh-history))

      (defun eshell-mode-configuration ()
        (with-eval-after-load 'evil-collection
          (+emacs/key-bindings)
          (define-key evil-normal-state-local-map "I" (lambda () (interactive) (eshell-bol) (evil-insert 1)))
          (define-key evil-normal-state-local-map (kbd "S") (lambda () (interactive) (eshell-bol) (kill-line) (evil-append 1)))
          (define-key evil-normal-state-local-map (kbd "gk") 'eshell-previous-prompt)
          (define-key evil-normal-state-local-map (kbd "gk") 'eshell-next-prompt)
          (define-key evil-normal-state-local-map "\C-ws" (lambda () (interactive) (split-window-vertically) (other-window 1) (eshell "new")))
          (define-key evil-normal-state-local-map "\C-wv" (lambda () (interactive) (split-window-horizontally) (other-window 1) (eshell "new")))
          (define-key evil-normal-state-local-map (kbd "C-r") '+eshell/counsel-esh-history-normal)
          (define-key evil-insert-state-local-map (kbd "C-r") 'counsel-esh-history)
          (define-key evil-normal-state-local-map (kbd "<return>") '+eshell/goto-end-of-prompt)))

      (defun eshell/ff (&rest args)
        (apply #'find-file args))

      (add-hook 'eshell-directory-change-hook 'eshell-cwd-rename)
      (add-hook 'eshell-mode-hook 'eshell-mode-configuration))

                                            ;(use-package eshell-prompt-extras
                                            ;  :ensure t
                                            ;  :init
                                            ;  (setq eshell-highlight-prompt nil
                                            ;        eshell-prompt-function 'epe-theme-lambda))

    ;(use-package eshell-syntax-highlighting
    ;  :after esh-mode
    ;  :ensure t 
    ;  :config
    ;  (eshell-syntax-highlighting-global-mode +1))
  #+end_src

* Magit

  #+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :config
    (evil-leader/set-key "gg" 'magit)
    (evil-leader/set-key "gd" 'magit-diff)
    (evil-leader/set-key "gb" 'magit-blame)
    (evil-leader/set-key "gl" 'magit-log-branches)
    (evil-leader/set-key "gf" 'magit-log-buffer-file))
  (use-package evil-magit
    :ensure t)
  #+end_src

* Check spelling inside git commit and markdown
  #+begin_src emacs-lisp
(use-package flyspell
  ;; Spell-checking of emacs buffers.
  :diminish (flyspell-mode)
  :commands flyspell-mode
  :init
  (progn
    (add-hook 'git-commit-mode-hook 'flyspell-mode)
    (add-hook 'org-mode-hook 'flyspell-mode)
    (add-hook 'markdown-mode-hook 'flyspell-mode)))
  #+end_src
  
* Language specific stuff
** Readable data files
   #+begin_src emacs-lisp
  (use-package yaml-mode :ensure t)
  (use-package json-mode :ensure t)
   #+end_src
** Go
   #+begin_src emacs-lisp
  (use-package go-mode
  :ensure t)
   #+end_src
** Clojure
   #+begin_src emacs-lisp
  (use-package clojure-mode :ensure t :defer t)
  (use-package cider :ensure t :defer t)
   #+end_src

** JS and stuff 
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq js-indent-level 2))

     (use-package web-mode
       :ensure t
       :defer t
       :custom
       (web-mode-markup-indent-offset 2)
       (web-mode-css-indent-offset 2)
       (web-mode-code-indent-offset 2)
       :config
       (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
       (add-to-list 'auto-mode-alist '("\\.jsx?$" . web-mode)))

     (use-package add-node-modules-path :ensure t)
   #+end_src

* Postman

  #+begin_src emacs-lisp
(use-package restclient
  :ensure t
  :config
  (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode)))
  #+end_src

* Jupyter notebooks
  #+begin_src emacs-lisp 
   (use-package ein
    :ensure t
    :init
    (setq ein:polymode t)
    :config
    (setq ein:polymode t))
  #+end_src

* Olivietty for writing
  #+begin_src emacs-lisp
(use-package olivetti
 :ensure t)
  #+end_src

* Eshell functions
#+begin_src emacs-lisp
  (defun eshell/awswhoami (&rest args)
    (let ((profile (getenv "AWS_PROFILE")))
      (message (if (null profile) "default" profile))))

(defun slurp (f)
  (with-temp-buffer
    (insert-file-contents f)
    (buffer-substring-no-properties
       (point-min)
       (point-max))))

  (defun eshell/awsprofile (&rest args)
    (require 'seq)
    (let* ((matches (seq-filter (apply-partially 'string-match "\^\[*.\]\$")
                                (split-string (slurp "~/.aws/credentials"))))
           (trim (seq-map (lambda (x) (string-trim x "\\[" "\\]")) matches))
           (choice (ivy-read "AWS Profile: " trim)))
      (setenv "AWS_PROFILE" choice)))
#+end_src

