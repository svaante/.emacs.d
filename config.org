* Basic
  #+BEGIN_SRC emacs-lisp
    ;; this is what the man told me to do
    (setq comp-speed 2)
    (setq package-native-compile t)

    ;; remove gui elements
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (menu-bar-mode -1)

    ;; set fringe style to minimal
    (set-fringe-style 0)

    ;; remove visual bell
    (setq visible-bell       nil
          ring-bell-function #'ignore)

    ;; set default dir to home
    (setq default-directory "~/")

    ;; follow symlinks
    (setq vc-follow-symlinks t)

    ;; spaces not tabs
    (setq-default indent-tabs-mode nil)

    ;; no backup files
    (setq make-backup-files nil)
    (global-auto-revert-mode t)

    ;; y/n will do
    (fset 'yes-or-no-p 'y-or-n-p)

    ;; stop the insessent blinking
    (blink-cursor-mode 0)

    ;; Backup trails is worse then chem-trails, losing patches is 99% of the time my fault
    (setq auto-save-default nil)

    ;; perf
    (setq gc-cons-threshold 100000000)
    (setq read-process-output-max (* 1024 1024))

    ;; Remove that pesky help window
    (setq inhibit-startup-screen t)
  #+END_SRC

* Platform
** Mac
   #+BEGIN_SRC  emacs-lisp
     (if (eq system-type 'darwin)
         (progn
           (setq mac-option-key-is-meta t)
           (setq mac-right-option-modifier nil)
           (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
           (add-to-list 'default-frame-alist '(ns-appearance . light))))

     (if (eq system-type 'gnu/linux)
         (progn
           (global-set-key (kbd "C-+") 'text-scale-increase)
           (global-set-key (kbd "C--") 'text-scale-decrease)))
   #+END_SRC
   
* Package
  #+begin_src emacs-lisp
    (require 'package)

    (add-to-list 'package-archives
                 '("melpa" . "https://melpa.org/packages/"))

    ;; Initialise the packages, avoiding a re-initialisation.
    (unless (bound-and-true-p package--initialized)
      (setq package-enable-at-startup nil)
      (package-initialize))

    ;; Unless quelpa is installed install it
    (unless (package-installed-p 'quelpa)
      (with-temp-buffer
        (url-insert-file-contents "https://raw.githubusercontent.com/quelpa/quelpa/master/quelpa.el")
        (eval-buffer)
        (quelpa-self-upgrade)))

    (eval-when-compile
      (require 'quelpa))

    ;; Configure `use-package' prior to loading it.
    (eval-and-compile
      (setq use-package-always-ensure nil)
      (setq use-package-always-defer nil)
      (setq use-package-always-demand nil)
      (setq use-package-expand-minimally nil)
      (setq use-package-enable-imenu-support t))

    ;; Install quelpa-use-package 
    (unless (package-installed-p 'quelpa-use-package)
      (quelpa
       '(quelpa-use-package
         :fetcher git
         :url "https://github.com/quelpa/quelpa-use-package.git")))

    (eval-when-compile
      (require 'quelpa-use-package))
  #+end_src

* Key mappings
** Global mappings
   #+begin_src emacs-lisp
     (use-package emacs
       :after evil
       :config
       (defun +emacs/split-follow-window-vertically ()
         "Split and follow window vertically."
         (interactive)
         (split-window-vertically) (other-window 1))

       (defun +emacs/split-follow-window-horizontally ()
         "Split and follow window horizontally."
         (interactive)
         (split-window-horizontally) (other-window 1))

       ;; create my own global intercept map for global evil keybindings
       (defvar global-intercept-mode-map (make-sparse-keymap)
         "High precedence keymap.")

       (define-minor-mode global-intercept-mode
         "Global minor mode for higher precedence keybindings."
         :global t)

       (global-intercept-mode)

       (dolist (state '(normal visual insert))
         (evil-make-intercept-map
          ;; NOTE: This requires an evil version from 2018-03-20 or later
          (evil-get-auxiliary-keymap global-intercept-mode-map state t t)
          state))

       ;; HACK: To seperate C-i with <tab>
       (define-key input-decode-map (kbd "C-i") (kbd "H-i"))
       (evil-define-key '(normal insert) global-intercept-mode-map
         "\C-j" 'evil-window-down
         "\C-k" 'evil-window-up
         "\C-h" 'evil-window-left
         "\C-l" 'evil-window-right
         "\C-j" 'evil-window-down
         "\C-k" 'evil-window-up
         "\C-h" 'evil-window-left
         "\C-l" 'evil-window-right
         (kbd "H-i") 'gumshoe-backtrack-forward
         "\C-o" 'gumshoe-backtrack-back
         "\C-ws" '+emacs/split-follow-window-vertically
         "\C-wv" '+emacs/split-follow-window-horizontally))
   #+end_src

** Evil
   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :ensure evil
       :init
       (setq evil-want-C-i-jump nil)
       (setq evil-want-integration t)
       (setq evil-want-keybinding nil)
       (setq evil-jumps-cross-buffers nil)
       (setq evil-want-Y-yank-to-eol t)
       (setq evil-want-C-u-scroll t)
       (setq evil-search-module 'evil-search)
       (setq-default evil-symbol-word-search t)
       (setq-default evil-shift-width 2)
       :config
       ;; use symbols instead of words when using the vim subject "word"
       (defalias #'forward-evil-word #'forward-evil-symbol)

       ;; run the macro in the q register
       (evil-define-key 'normal 'global "Q" "@q")

       ;; my common misspellings
       (evil-ex-define-cmd "E[dit]" 'evil-edit)
       (evil-ex-define-cmd "W[rite]" 'evil-write)
       (evil-ex-define-cmd "Wq" 'evil-save-and-close)
       (evil-ex-define-cmd "WQ" 'evil-save-and-close)
       (evil-ex-define-cmd "Wq" 'evil-save-and-close)
       (evil-ex-define-cmd "Qa[ll]" "quitall")
       (evil-ex-define-cmd "qA[ll]" "quitall")
       (evil-ex-define-cmd "QA[ll]" "quitall")
       (evil-mode 1))

     (use-package evil-surround
       :ensure t
       :config
       (global-evil-surround-mode 1))

     (use-package evil-escape
       :diminish
       :ensure t
       :init
       (setq evil-escape-delay 0.2)
       (setq evil-escape-unordered-key-sequence t)
       (setq-default evil-escape-key-sequence "jk")
       :config
       (evil-escape-mode))

     (use-package evil-collection
       :after evil
       :ensure t
       :config
       ;; magit uses 'C-i' as tab like GUI emacs doesn't exist
       (evil-define-key 'normal magit-mode-map (kbd "<tab>") #'magit-section-cycle)

       (thread-last evil-collection-mode-list
         (remove 'eshell)
         (setq evil-collection-mode-list))
       (evil-collection-init)
       (diminish 'evil-collection-unimpaired-mode))

      (use-package evil-org
        :diminish
        :defer t
        :ensure t
        :after org
        :hook ((org-mode . evil-org-mode)
               (evil-org-mode . (lambda ()
                                  (evil-org-set-key-theme '(textobjects
                                                            insert
                                                            return
                                                            additional
                                                            shift
                                                            todo))))))
   #+END_SRC

** Leader mappings
   #+BEGIN_SRC emacs-lisp
     (use-package evil-leader
       :ensure t
       :config
       (setq evil-leader/in-all-states 1)
       (global-evil-leader-mode)
       (evil-leader/set-leader "<SPC>")
       (evil-leader/set-key
         ;"." 'counsel-find-file
         ;"f" '+ispell/toogle-english-swedish-dictonary
         ;"hh" 'counsel-describe-function
         ;"hb" 'counsel-descbinds
         ;"hv" 'counsel-describe-variable
         ;"b" 'ivy-switch-buffer
         ;"m" 'counsel-bookmark
         ;"y" 'counsel-yank-pop
         ;"os" 'counsel-org-goto
         ;"i" 'counsel-imenu
         ;":" 'counsel-M-x
         "wt" (lambda () (interactive) (toggle-frame-maximized))))
       #+END_SRC 

* Looks
** Fonts
   #+begin_src emacs-lisp
     ;; Set my font
     (set-frame-font "Hack-10" nil t)

     ;; Emoji support
     (set-fontset-font t 'symbol "Apple Color Emoji")
     (set-fontset-font t 'symbol "Noto Color Emoji" nil 'append)
     (set-fontset-font t 'symbol "Segoe UI Emoji" nil 'append)
     (set-fontset-font t 'symbol "Symbola" nil 'append)
   #+end_src
  
** Themes
   #+BEGIN_SRC emacs-lisp
     (use-package modus-themes
       :ensure t
       :config
       (setq modus-themes-mode-line '(accented borderless 3d))
       (setq modus-themes-org-blocks 'tinted-background)
       (setq modus-themes-headings 
             '((1 . section)
               (2 . rainbow-line)
               (t . rainbow-no-bold)))
       (load-theme 'modus-operandi t))

     (use-package grandshell-theme
       :ensure t
       :config)

     (use-package org
       :config
       (setq org-return-follows-link t)
       (custom-set-faces
        '(org-level-1 ((t (:inherit outline-1 :height 1.2))))
        '(org-level-2 ((t (:inherit outline-2 :height 1.15))))
        '(org-level-3 ((t (:inherit outline-3 :height 1.1))))
        '(org-level-3 ((t (:inherit outline-3 :height 1.05))))))
   #+END_SRC

** Mode-line
   #+begin_src emacs-lisp
     (use-package diminish
       :ensure
       :after use-package)

     (use-package emacs
       :config
       (setq mode-line-percent-position '(-3 "%p"))
       (setq mode-line-defining-kbd-macro
             (propertize " Macro" 'face 'mode-line-emphasis))
       (setq-default mode-line-format
                     '("ðŸŒ»"
                       "%e"
                       ""
                       mode-line-front-space
                       mode-line-mule-info
                       mode-line-client
                       mode-line-modified
                       mode-line-remote
                       mode-line-frame-identification
                       mode-line-buffer-identification
                       " "
                       mode-line-position
                       (vc-mode vc-mode)
                       " "
                       mode-line-modes
                       " "
                       mode-line-misc-info
                       mode-line-end-spaces))
       :init
       (column-number-mode 1))
   #+end_src

** Relative line numbers
   #+BEGIN_SRC emacs-lisp
     (use-package emacs
       :init
       (setq display-line-numbers-type 'relative)
       ;(add-hook 'text-mode-hook #'display-line-numbers-mode)
       ;(add-hook 'prog-mode-hook #'display-line-numbers-mode)
       )
   #+END_SRC

** Match paren 
   #+begin_src  emacs-lisp
     (use-package paren
       :config
       (setq show-paren-style 'parenthesis)
       (setq show-paren-when-point-in-periphery nil)
       (setq show-paren-when-point-inside-paren nil)
       (setq show-paren-delay 0)
       (show-paren-mode +1))
   #+end_src
  
** White space
 #+BEGIN_SRC emacs-lisp
   (use-package global-whitespace
     :defer t
     ;:hook (prog-mode . whitespace-mode)
     :diminish
     :init
     (setq whitespace-style '(face trailing)))
 #+END_SRC
  
** Package dashboard
   #+BEGIN_SRC emacs-lisp
   (use-package dashboard
     :diminish
     :ensure t
     :config
     (setq dashboard-items '((recents  . 10)
                             (bookmarks . 10)))
     (dashboard-setup-startup-hook))
   #+END_SRC

** Visual lines
   #+begin_src emacs-lisp
    (use-package simple
      :diminish
      (global-visual-line-mode t))
   #+end_src

* Buffer navigation
** Gumshoe
   #+begin_src emacs-lisp
     (defun consult-gumshoe-global ()
       (interactive)
       (consult-global-mark (ring-elements (oref gumshoe--global-backlog log))))

     (use-package gumshoe
       :ensure t
       :diminish 'global-gumshoe-mode
       :config
       (setq gumshoe-display-buffer-action '(display-buffer-same-window))
       (evil-leader/set-key "js" 'consult-gumshoe-global)
       (global-gumshoe-mode 1))
   #+end_src

** Narrow
   #+BEGIN_SRC emacs-lisp
     (defun narrow-or-widen-dwim (p)
     "Widen if buffer is narrowed, narrow-dwim otherwise.
     Dwim means: region, org-src-block, org-subtree, or
     defun, whichever applies first.  Narrowing to
     org-src-block actually calls `org-edit-src-code'.

     With prefix P, don't widen, just narrow even if buffer
     is already narrowed."
       (interactive "P")
       (declare (interactive-only))
       (cond ((and (buffer-narrowed-p) (not p)) (widen))
             ((region-active-p)
              (narrow-to-region (region-beginning)
                                (region-end)))
             ((derived-mode-p 'org-mode)
              ;; `org-edit-src-code' is not a real narrowing
              ;; command. Remove this first conditional if
              ;; you don't want it.
              (cond ((ignore-errors (org-edit-src-code) t)
                     (delete-other-windows))
                    ((ignore-errors (org-narrow-to-block) t))
                    (t (org-narrow-to-subtree))))
             ((derived-mode-p 'latex-mode)
              (LaTeX-narrow-to-environment))
             (t (narrow-to-defun))))

     (evil-leader/set-key "z" 'narrow-or-widen-dwim)
   #+END_SRC

** Avy
   #+begin_src emacs-lisp
     (use-package avy
       :config
       (evil-leader/set-key
         "jj" 'evil-avy-goto-char-timer
         "jw" 'avy-goto-word-0
         "jl" 'avy-goto-line))
   #+end_src

* Org
   #+BEGIN_SRC emacs-lisp
     (use-package org
       :config
       (setq org-babel-python-command "python3")
       (org-babel-do-load-languages
        'org-babel-load-languages
        '(
          (shell . t)
          (python . t)))
       (evil-leader/set-key "os" 'org-store-link))

     (defun +org-agenda-goto (&optional highlight)
       "Go to the entry at point in the corresponding Org file using same window."
       (interactive)
       (let* ((marker (or (org-get-at-bol 'org-marker)
                          (org-agenda-error)))
              (buffer (marker-buffer marker))
              (pos (marker-position marker)))
         ;; FIXME: use `org-switch-to-buffer-other-window'?
         (switch-to-buffer buffer)
         (widen)
         (push-mark)
         (goto-char pos)
         (when (derived-mode-p 'org-mode)
           (org-show-context 'agenda)
           (recenter (/ (window-height) 2))
           (org-back-to-heading t)
           (let ((case-fold-search nil))
             (when (re-search-forward org-complex-heading-regexp nil t)
               (goto-char (match-beginning 4)))))
         (run-hooks 'org-agenda-after-show-hook)
         (and highlight (org-highlight (point-at-bol) (point-at-eol)))))

     (defun +org-agenda-goto-narrow ()
       (interactive)
       (+org-agenda-goto)
       (org-narrow-to-element))

     (use-package org-agenda
       :init
       (setq org-agenda-files '("~/org/todo.org"))
       :config
       (evil-leader/set-key
         "oa" 'org-agenda
         "ot" 'org-todo-list
         "ow" 'org-agenda-list)

       ;; been trying to use evil-org's evil-agenda only result was pain
       (evil-set-initial-state 'org-agenda-mode 'normal)
       (evil-define-key 'normal org-agenda-mode-map
         (kbd "<RET>") '+org-agenda-goto-narrow
         "q" 'org-agenda-quit
         "r" 'org-agenda-redo
         "K" 'org-agenda-priority-up
         "J" 'org-agenda-priority-down
         "n" 'org-agenda-add-note
         "t" 'org-agenda-todo
         "#" 'org-agenda-set-tags
         "j" 'org-agenda-next-line
         "k"  'org-agenda-previous-line
         "f" 'org-agenda-later
         "b" 'org-agenda-earlier
         "e" 'org-agenda-set-effort
         "." 'org-agenda-goto-today
         "H" 'org-agenda-do-date-earlier
         "L" 'org-agenda-do-date-later))

     (use-package org-capture
       :init
       (setq org-capture-templates '(("t" "Task Entry" entry
                                      (file+headline "~/org/todo.org" "Tasks")
                                      "* TODO %?  \n  %t\n  %a")

                                     ("n" "Note" entry
                                      (file+headline "~/org/notes.org" "Note")
                                      "* %?  \n  %t\n  %a")))
       :config
       (setq org-agenda-follow-indirect t)
       (setq org-refile-use-outline-path 'file)
       (setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
       (setq org-outline-path-complete-in-steps nil)

       (add-hook 'org-capture-mode-hook 'evil-insert-state)

       (evil-leader/set-key "oc" 'org-capture))

     (use-package ob-async :ensure t)

     (use-package org-superstar
       :ensure t
       :hook (org-mode . org-superstar-mode))

     (use-package orgit :ensure t)
   #+END_SRC

* Completion
** Package company
   Use company for packages
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :diminish company-mode
       :ensure t
       :config
       (setq company-backends '(company-files company-capf))
       (setq company-idle-delay 0)
       (setq company-minimum-prefix-length 1)
       (setq company-tooltip-align-annotations t)
       (setq company-global-modes '(not eshell-mode))

       (global-company-mode 1)
       (company-tng-mode +1))
   #+END_SRC
   
** Vertico, consult, embark
   #+begin_src emacs-lisp
     (use-package vertico
       ;:load-path "~/.emacs.d/gits/vertico"
       :init
       (vertico-mode)
       ;; Grow and shrink the Vertico minibuffer
       ;; (setq vertico-resize t)

       ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
       (setq vertico-cycle t)
       (setq enable-recursive-minibuffers t)

       (defun crm-indicator (args)
         (cons (concat "[CRM] " (car args)) (cdr args)))
       (advice-add #'completing-read-multiple :filter-args #'crm-indicator))

     (use-package vertico-repeat
       :load-path "~/.emacs.d/gits/vertico/extensions"
       :init
       (evil-leader/set-key "r" 'vertico-repeat))

     (use-package vertico-directory
       :load-path "~/.emacs.d/gits/vertico/extensions"
       ;; More convenient directory navigation commands
       :bind (:map vertico-map
                   ("RET" . vertico-directory-enter)
                   ("DEL" . vertico-directory-delete-char)
                   ("M-DEL" . vertico-directory-delete-word))
       ;; Tidy shadowed file names
       :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

     (use-package orderless
       :ensure t
       :init
       (setq completion-styles '(orderless basic emacs22)
             completion-category-defaults nil
             completion-category-overrides '((file (styles basic partial-completion)))))

     ;; Persist history over Emacs restarts. Vertico sorts by history position.
     (use-package savehist
       :ensure t
       :init
       (savehist-mode))

     ;; Enable richer annotations using the Marginalia package
     (use-package marginalia
       :ensure t
       :init
       (marginalia-mode))

     (defun consult-line-evil-history (&rest _)
       "Add latest `consult-line' search pattern to the evil search history ring.
                    This only works with orderless and for the first component of the search."
       (when (and (bound-and-true-p evil-mode)
                  (eq evil-search-module 'evil-search))
         (let ((pattern (car (orderless-pattern-compiler (car consult--line-history)))))
           (add-to-history 'evil-ex-search-history pattern)
           (setq evil-ex-search-pattern (list pattern t t))
           (setq evil-ex-search-direction 'forward)
           (when evil-ex-search-persistent-highlight
             (evil-ex-search-activate-highlight evil-ex-search-pattern)))))

     (advice-add #'consult-line :after #'consult-line-evil-history)

     (use-package consult
       :ensure t
       :init
       (setq consult-project-root-function 'projectile-project-root)
       (define-key minibuffer-local-map (kbd "C-r") 'consult-history)
       (evil-leader/set-key
         "." 'find-file-at-point
         "SPC" 'projectile-find-file
         "pg" 'consult-ripgrep
         "pl" 'consult-locate
         "b" 'consult-buffer
         "i" 'consult-outline
         "hh" 'describe-function
         "hv" 'describe-variable
         "m" 'consult-bookmark
         "y" 'consult-yank-pop
         ":" 'execute-extended-command
         "s"  'consult-line)
       :config
       ;; Do not preview buffers in consult-buffer 
       (consult-customize consult-buffer :preview-key '())

       ;; Add eshell as a buffer source
       (defvar eshell-buffer-source
         `(:name     "Eshell Buffer"
                     :narrow   (?e . "Eshell")
                     :hidden   t
                     :category buffer
                     :face     consult-buffer
                     :history  buffer-name-history
                     :state    ,#'consult--buffer-state
                     :enabled  ,(lambda () consult-project-root-function)
                     :items
                     ,(lambda ()
                        (consult--buffer-query :mode 'eshell-mode
                                               :as #'buffer-name)))
         "Eshell buffer candidate source for `consult-buffer'.")
       (add-to-list 'consult-buffer-sources 'eshell-buffer-source 'append)

       ;; Use consult as the completion-in-region
       (setq completion-in-region-function
             (lambda (&rest args)
               (apply (if vertico-mode
                          #'consult-completion-in-region
                        #'completion--in-region)
                      args))))

     (use-package which-key
       :ensure t
       :diminish which-key-mode
       :init
       (which-key-mode))

     (defun +eshell-there (file)
       "Run eshell in directory of FILE."
       (interactive "Directory: ")
       (let ((default-directory (file-name-directory
                                 (expand-file-name
                                  (substitute-in-file-name file)))))
         (eshell-here t)))

     (use-package embark
       :init
       :config
       (define-key minibuffer-local-map (kbd "C-SPC") 'embark-act)
       (define-key minibuffer-local-map (kbd "C-return>") 'embark-export)

       ;; Show Embark actions via which-key
       (setq embark-action-indicator
             (lambda (map)
               (which-key--show-keymap "Embark" map nil nil 'no-paging)
               #'which-key--hide-popup-ignore-command)
             embark-become-indicator embark-action-indicator))

     (use-package embark-consult
       :ensure t
       :after (embark consult))

     (define-key embark-file-map "e" '+eshell-there)
   #+end_src

* Project management
** Projectile
  #+begin_src emacs-lisp
    (defun +projectile/projectile-run-project-with-comint ()
      (interactive)
      (let ((projectile-run-use-comint-mode t))
        (call-interactively 'projectile-run-project)))

    (use-package projectile
      :ensure t
      :quelpa (projectile :fetcher github :repo "waymondo/projectile")
      :config
      (projectile-mode +1)
      projectile-project-root-files #'( ".projectile" )
      projectile-project-root-files-functions #'(projectile-root-top-down
                                                 projectile-root-top-down-recurring
                                                 projectile-root-bottom-up
                                                 projectile-root-local)

      (setq projectile-switch-project-action 'projectile-dired)
      (evil-leader/set-key
        "pi" 'projectile-invalidate-cache
        "pt" 'projectile-test-project
        "pr" 'projectile-run-project
        "pd" '+projectile/projectile-run-project-with-comint
        "pc" 'projectile-compile-project
        "p!" 'projectile-run-async-shell-command-in-root
        "pq" 'projectile-toggle-between-implementation-and-test
        "pb" 'projectile-switch-to-buffer
        "pp" 'projectile-switch-project))
  #+end_src
** project.el
*** TODO Fix replace the comint command from projectile
   #+begin_src emacs-lisp
     ;(setq +project/cmd-history (make-hash-table))
     ;
     ;(defun +compilation-read-command (command)
     ;  (read-shell-command prefix command
     ;                      (if (equal (car compile-history) command)
     ;                          '(compile-history . 1)
     ;                        'compile-history)))
     ;
     ;(defun +project/compile (&optional type comint)
     ;  (interactive) 
     ;  (let* ((default-directory (project-root (project-current t)))
     ;         (hash-key (concat type default-directory))
     ;         (compile-command (gethash hash-key +project/cmd-history ""))
     ;         (compilation-buffer-name-function (lambda ()
     ;                                             (concat "*compilation" default-directory type "*")))
     ;         (prefix type)
     ;         (compilation-read-command #'+compilation-read-command))
     ;    (call-interactively #'compile comint)
     ;    (puthash hash-key (car compile-history) +project/cmd-history)))
     ;
     ;(+project/compile "Test: ")

     ;(cl-defmethod project-root ((project (head local)))
     ;  (cdr project))

     ;(defun +project-files-in-directory (dir)
     ;  "Use `fd' to list files in DIR."
     ;  (let* ((default-directory dir)
     ;         (localdir (file-local-name (expand-file-name dir)))
     ;         (command (format "fd -t f -0 . %s" localdir)))
     ;    (project--remote-file-names
     ;     (sort (split-string (shell-command-to-string command) "\0" t)
     ;           #'string<))))

     ;(cl-defmethod project-files ((project (head local)) &optional dirs)
     ;  "Override `project-files' to use `fd' in local projects."
     ;  (mapcan #'+project-files-in-directory
     ;          (or dirs (list (project-root project)))))

     ;(defun +project-try-local (dir)
     ;  "Determine if DIR is a non-Git project.
     ;DIR must include a .project file to be considered a project."
     ;  (let ((root (locate-dominating-file dir ".project")))
     ;    (and root (cons 'local root))))

     ;(use-package project
     ;  :config
     ;  (setq project-find-functions '(+project-try-local project-try-vc))
     ;  (evil-leader/set-key
     ;    "pp" 'project-switch-project
     ;     "pe" (lambda () (interactive) (+eshell-there (project-root)))
     ;  )
     ;)
   #+end_src

* Terminal
** Get $PATH from bash/zsh profiles
   #+begin_src emacs-lisp
     (use-package exec-path-from-shell
       :ensure t
       :config
       (exec-path-from-shell-initialize))
   #+end_src
   
** Eshell
   #+begin_src emacs-lisp
     ;; Require file where 'eshell/pwd is defined for further usage
     (require 'em-dirs)

     (defun eshell-pwd-rename (&optional i)
       "Renames eshell buffer to *eshell <wd> <number of buffers with this name>*"
       (interactive)
       (unless i (setq i 0))
       (let ((b-name (if (zerop i)
                         (concat "*eshell " (eshell/pwd) "*")
                       (concat "*eshell " (eshell/pwd) "*<" (number-to-string i) ">"))))
         (cond ((string= (buffer-name) b-name) nil)
               ((not (get-buffer b-name)) (rename-buffer b-name))
               (t (eshell-pwd-rename (1+ i))))))

     (defun eshell-here (&optional same-window)
       "Opens up a new shell in the directory associated with the current buffer's file."
       (interactive)
       (let ((b-name (concat "*eshell " (eshell/pwd) "*")))
         (if (or (not (get-buffer b-name))
                 (bound-and-true-p eshell-mode))
             (let ((buf (eshell "new")))
               (when (not same-window)
                 (progn 
                   (switch-to-buffer (other-buffer buf))
                   (switch-to-buffer-other-window buf)))
               (eshell-pwd-rename))
           (switch-to-buffer-other-window (get-buffer b-name)))))

     (defun eshell-project-root ()
       (interactive)
       (let ((buf (projectile-run-eshell 1)))
         (switch-to-buffer (other-buffer buf))
         (switch-to-buffer-other-window buf)))

     (defun +eshell/goto-end-of-prompt ()
       "Move cursor to the prompt when switching to insert mode (if point isn't
                                   already there)."
       (interactive)
       (goto-char (point-max))
       (evil-append 1))

     (defun +eshell/consult-esh-history-normal ()
       "Move cursor to the end of the buffer before calling counsel-esh-history
                                     and change `state` to insert."
       (interactive)
       (goto-char (point-max))
       (eshell-bol)
       (unwind-protect
           (kill-line)
         (progn
           (evil-append-line 0)
           (consult-history))))

     (defun +eshell-create-and-rename ()
       (interactive)
       (eshell "new")
       (eshell-pwd-rename))

     (defun eshell-after-split (&rest _)
       (when (bound-and-true-p eshell-mode)
         (eshell-here t)))

     (defun +eshell-previous-prompt-hack ()
       "With prompt as field eshell-previous-prompt sets cursor at the beggining of the line and not at prompt begin"
       (interactive)
       (call-interactively 'eshell-previous-prompt)
       (call-interactively 'eshell-next-prompt))

     (defun eshell-mode-configuration ()
       (push 'eshell-tramp eshell-modules-list)

       ;; Save command history when commands are entered
       (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

       ;; Truncate buffer for performance
       (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

       (eshell-hist-initialize)

       (evil-define-key 'normal 'local
         "I" (lambda () (interactive) (eshell-bol) (evil-insert 1))
         (kbd "S") (lambda () (interactive) (eshell-bol) (kill-line) (evil-append 1))
         (kbd "C-p") '+eshell-previous-prompt-hack
         (kbd "C-n") 'eshell-next-prompt
         "\C-ws" (lambda () (interactive) (split-window-vertically) (other-window 1) (eshell "new"))
         "\C-wv" (lambda () (interactive) (split-window-horizontally) (other-window 1) (eshell "new"))
         (kbd "C-r") '+eshell/consult-esh-history-normal
         (kbd "<return>") '+eshell/goto-end-of-prompt)

       (evil-define-key 'visual 'local
         (kbd "<return>") (lambda () (interactive) (progn (eshell-send-input t) (evil-normal-state))))

       (evil-define-key 'insert 'local
         (kbd "C-r") 'consult-history))

     (defun +eshell-make-field ()
       "Make text in front of the point a field, useful for prompts."
       (let ((inhibit-read-only t))
         (add-text-properties
          (line-beginning-position) (point)
          (list 'field t
                'rear-nonsticky t))))

      (defun +eshell-global-history-init ()
        "Share the eshell history ring between the eshell buffers.
     Addice add this :after `eshell-hist-initialize`"
        (or (boundp 'eshell-global-history-ring)
            (setq eshell-global-history-ring (ring-copy eshell-history-ring)))
        (setq eshell-history-ring eshell-global-history-ring))

     (use-package eshell
       :ensure t
       :hook ((eshell-first-time-mode . eshell-mode-configuration)
              (eshell-directory-change . eshell-pwd-rename)
              (eshell-after-prompt . +eshell-make-field))
       :init
       (setq eshell-hist-ignoredups t
             eshell-save-history-on-exit t
             eshell-destroy-buffer-when-process-dies t)

       (setenv "PAGER" "cat")

       (advice-add '+emacs/split-follow-window-horizontally :after #'eshell-after-split)
       (advice-add '+emacs/split-follow-window-vertically :after #'eshell-after-split)
       (advice-add 'eshell-hist-initialize :after #'+eshell-global-history-init)

       (defun eshell/exit ()
         (kill-current-buffer)
         (when (not (one-window-p))
           (delete-window)))

       (evil-leader/set-key "e" 'eshell-here
         "pe" 'eshell-project-root))
   #+end_src
  
** Eshell functions
 #+begin_src emacs-lisp
   (defun eshell/ff (&rest args)
     (apply #'find-file args))

   (defun eshell/awswhoami (&rest args)
     (let ((profile (getenv "AWS_PROFILE")))
       (message (if (null profile) "default" profile))))

   (defun slurp (f)
     (with-temp-buffer
       (insert-file-contents f)
       (buffer-substring-no-properties
        (point-min)
        (point-max))))

   (defun eshell/awsprofile (&rest args)
     (require 'seq)
     (let* ((matches (seq-filter (apply-partially 'string-match "\^\[*.\]\$")
                                 (split-string (slurp "~/.aws/credentials"))))
            (trim (seq-map (lambda (x) (string-trim x "\\[" "\\]")) matches))
            (choice (ivy-read "AWS Profile: " trim)))
       (setenv "AWS_PROFILE" choice)))

   (require 'cl-lib)
   (require 'subr-x)

   (defun eshell/absolut-ls (&optional path)
     (let* ((fixed-path (if path path "./"))
            (files-command (concat "cd " fixed-path "ls " fixed-path " | xargs -I {} readlink -f -- {}"))
            (command-result (shell-command-to-string files-command))
            (files (split-string command-result "\n")))
       (when (not (string< "ls: cannot access" command-result)) files)))

   (setq debug-on-error '())

   (defun eshell/ls-map (&optional maybe-path &rest maybe-command)
     (let* ((files-and-command (if-let (maybe-files (eshell/absolut-ls maybe-path))
                                   (list maybe-files maybe-command)
                                 (list (eshell/absolut-ls) (cons maybe-path maybe-command))))
            (files (car files-and-command))
            (command (car (cdr files-and-command)))
            (fixed-command (if (member "$" command) command (append command '("$")))))
       (string-join
        (cl-map 'list
                (lambda (file)
                  (let* ((command-with-inserted-file (string-join
                                                      (cl-map 'list
                                                              (lambda (s)
                                                                ()
                                                                (if (string= s "$") file s))
                                                              fixed-command)
                                                      " "))
                         (result (shell-command-to-string command-with-inserted-file)))
                    (concat file ":\n" result)))
                files)
        "\n")))
 #+end_src

* Misc
** wgrep
   Change stuff in the grep buffer
   #+begin_src emacs-lisp
     (use-package wgrep :ensure t)
   #+end_src
** Spell checking spelling
   #+begin_src emacs-lisp
     (defun +ispell/toogle-english-swedish-dictonary ()
       "Toggle `IspellÂ´ dictionary between English and Swedish."
       (interactive)
       (when (bound-and-true-p flyspell-mode)
         (cond
          ((string-equal ispell-local-dictionary "en_US")   (ispell-change-dictionary "swedish"))
          ((string-equal ispell-local-dictionary "swedish") (ispell-change-dictionary "en_US"))
          (t                                                (ispell-change-dictionary "en_US")))))

     (use-package flyspell
       :ensure t
       ;;inside git commit and markdown
       :hook ((git-commit-mode org-mode markdown-mode) . flyspell-mode)
       :config
       (setq flyspell-default-dictionary "en_US"))

     (evil-leader/set-key
       "ff" '+ispell/toogle-english-swedish-dictonary
       "fp" (lambda ()
              (interactive)
              (ispell-change-dictionary "en_US")
              (flyspell-prog-mode)))

   #+end_src

** Fix color stuff
   #+begin_src  emacs-lisp
     (use-package xterm-color
       :disable
       :ensure t
       :config
       (setq compilation-environment '("TERM=xterm-256color"))

       (defun +emacs/advice-compilation-filter (f proc string)
         (funcall f proc (xterm-color-filter string)))

       (advice-add 'compilation-filter :around #'+emacs/advice-compilation-filter))
   #+end_src
** Scratch
   #+begin_src emacs-lisp
     ;; Eval code lisp in the *scratch* buffer
     (define-key lisp-interaction-mode-map (kbd "C-c C-c") 'eval-buffer)

     ;; Create text scratch buffer
     (defun create-or-switch-text-scratch-buffer ()
       (interactive)
       (let ((b-name "*text-scratch*"))
         (if (not (get-buffer b-name))
             (let ((buf (generate-new-buffer b-name)))
               (switch-to-buffer (other-buffer buf))
               (switch-to-buffer-other-window buf)
               (flyspell-mode)
               (evil-insert-state))
           (progn
             (switch-to-buffer-other-window (get-buffer b-name))
             (evil-insert-state)))))

     (evil-leader/set-key "t" 'create-or-switch-text-scratch-buffer)
   #+end_src


* Programming
** LSP
   #+begin_src emacs-lisp
     (use-package lsp-mode
       :ensure t
       :hook (prog-mode . (lambda ()
                            (unless (derived-mode-p 'clojure-mode 'emacs-lisp-mode 'lisp-mode)
                              (lsp-deferred))))
       :config
       (defun lsp-mode-configuration ()
         (with-eval-after-load 'evil
           (define-key evil-normal-state-local-map "K" 'lsp-describe-thing-at-point)
           (define-key evil-normal-state-local-map "gd" 'lsp-find-definition)
           (define-key evil-normal-state-local-map "gr" 'lsp-find-references)))
       (setq lsp-file-watch-threshold 1000)
       (setq lsp-completion-provider :capf)
       (setq lsp-headerline-breadcrumb-enable nil)

       ;; enable lsp-mode inside of org babel edit src blocks
       (defun org-babel-edit-prep:python (babel-info)
         (setq-local buffer-file-name (->> babel-info caddr (alist-get :tangle))))

       (add-hook 'lsp-mode-hook 'lsp-mode-configuration)
       (evil-leader/set-key
         "lr" 'lsp-rename
         "lf" 'lsp-format-buffer))

     (use-package consult-lsp
       :ensure t
       :config
       (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols)
       (evil-leader/set-key
         "ls" 'consult-lsp-symbols))
   #+end_src

** Tree sitter
   #+begin_src emacs-lisp
     ;; Unfortunately tree-sitter does not work at the moment
     (use-package tree-sitter
       :disable
       :ensure t)

     (use-package tree-sitter-langs
       :disable
       :ensure t
       :hook (prog-mode . tree-sitter-mode))

     (use-package evil-textobj-treesitter
       :disable
       :quelpa (evil-textobj-treesitter :fetcher github :repo "meain/evil-textobj-treesitter")
       :after tree-sitter
       :config
           (define-key evil-outer-text-objects-map "f" (evil-textobj-treesitter-get-textobj "function.outer"))
           (define-key evil-inner-text-objects-map "f" (evil-textobj-treesitter-get-textobj "function.inner"))
           (define-key evil-outer-text-objects-map "c" (evil-textobj-treesitter-get-textobj "conditional.outer"))
           (define-key evil-inner-text-objects-map "c" (evil-textobj-treesitter-get-textobj "conditional.inner"))
           (define-key evil-outer-text-objects-map "p" (evil-textobj-treesitter-get-textobj "parameter.outer"))
           (define-key evil-inner-text-objects-map "p" (evil-textobj-treesitter-get-textobj "parameter.inner"))
           (define-key evil-outer-text-objects-map "C" (evil-textobj-treesitter-get-textobj "class.outer"))
           (define-key evil-inner-text-objects-map "C" (evil-textobj-treesitter-get-textobj "class.inner")))
   #+end_src

** Readable data files
   #+begin_src emacs-lisp
  (use-package yaml-mode :ensure t)
  (use-package json-mode :ensure t)
   #+end_src
 
** Go
   #+begin_src emacs-lisp
  (use-package go-mode
  :ensure t)
   #+end_src
 
** Clojure
   #+begin_src emacs-lisp
  (use-package clojure-mode :ensure t :defer t)
  (use-package cider :ensure t :defer t)
   #+end_src

** JS
   #+begin_src emacs-lisp
     (use-package emacs
       :config
       (setq js-indent-level 2))

     (use-package web-mode
       :ensure t
       :defer t
       :custom
       (web-mode-markup-indent-offset 2)
       (web-mode-css-indent-offset 2)
       (web-mode-code-indent-offset 2)
       :config
       (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
       (add-to-list 'auto-mode-alist '("\\.jsx?$" . web-mode)))

     (use-package add-node-modules-path :ensure t)
   #+end_src

** Python
  #+begin_src emacs-lisp
    (use-package elpy
      :ensure t
      :init
      (setq python-shell-interpreter "ipython3"
            python-shell-interpreter-args "-i --simple-prompt")
      :config
      (evil-leader/set-key "q" 'elpy-shell-switch-to-shell)
      (add-hook 'elpy-mode-hook (lambda () (highlight-indentation-mode -1)))
      (elpy-enable))

    (use-package lsp-pyright
      :ensure t
      :after lsp-mode
      :custom
      (lsp-pyright-auto-import-completions nil)
      (lsp-pyright-typechecking-mode "off"))
   #+end_src

   #+RESULTS:

** Godot
   #+begin_src emacs-lisp
     (use-package gdscript-mode
       :ensure t
       :config
       (evil-leader/set-key-for-mode 'gdscript-mode "pr" 'gdscript-godot-run-project)
       (setq gdscript-use-tab-indents nil)
       (setq gdscript-indent-offset 4))
   #+end_src

** Devdocs
 #+begin_src  emacs-lisp
   (use-package devdocs
     :ensure t
     :config
     (evil-leader/set-key "k" (lambda () (interactive) (devdocs-lookup t))))
 #+end_src

** Compilation
 #+begin_src emacs-lisp
   (use-package emacs
     :init
     (setq compilation-scroll-output t))
 #+end_src
 
* Applications
** Dired
   #+begin_src emacs-lisp
     (use-package dired
       :config
       (defun dired-mode-configuration ()
         (with-eval-after-load 'evil-collection
           (evil-collection-define-key 'normal 'dired-mode-map (kbd "TAB") nil)
           (evil-collection-define-key 'normal 'dired-mode-map (kbd "<tab>") 'dired-subtree-toggle)
           (dired-hide-details-mode 1)))

       (add-hook 'dired-mode-hook 'dired-mode-configuration))

     (use-package dired-subtree :ensure t)
   #+end_src
** Magit
   #+begin_src emacs-lisp
     (use-package magit
       :ensure t
       :config
       (evil-leader/set-key "gg" 'magit)
       (evil-leader/set-key "gd" 'magit-diff)
       (evil-leader/set-key "gb" 'magit-blame)
       (evil-leader/set-key "gl" 'magit-log-branches)
       (evil-leader/set-key "gc" 'magit-checkout)
       (evil-leader/set-key "gf" 'magit-fetch-all)
       (evil-leader/set-key "gf" 'magit-log-buffer-file))
   #+end_src
** Tramp
   #+begin_src emacs-lisp
     (use-package tramp
       :init
       (setq tramp-default-method "ssh"))
   #+end_src

** Postman
   #+begin_src emacs-lisp
 (use-package restclient
   :ensure t
   :config
   (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode)))
   #+end_src

** Jupyter notebooks
   #+begin_src emacs-lisp 
    (use-package ein
     :ensure t
     :config
     (setq ein:polymode t))
   #+end_src

** Axe aws
   #+begin_src emacs-lisp
         (use-package axe
         :ensure nil
         :load-path "~/Workspace/axe/"
         :config
         (setq axe-region 'eu-central-1)
         (setq axe-profile 'default)
         (setq axe-logs-log-groups-prefix
               '("/aws/lambda/"
                 "/aws/codebuild/"
                 "/aws/lambda/IkeaServices-User"
                 "/aws/lambda/IkeaServices"
                 "/aws/lambda/Environment"
                 "/aws/lambda/HealthAndMonitoring"
                 "/aws/lambda/SecretsReplication"
                 "/aws/lambda/Grafana"
                 "/aws/lambda/DeploymentInfrastructure"
                 "/aws/lambda/PipelineInfrastructure"
                 "/aws/lambda/GlobalInfrastructure"
                 "/aws/lambda/FunctionalTestUserPool"
                 "/aws/lambda/InternalInfrastructure"
                 "/aws/lambda/healthcheckroute53"
                 "/aws/lambda/Assets"
                 "/aws/lambda/SecurityHeaders"
                 "/aws/lambda/FeatureToggles"
                 "/aws/lambda/DeployDefaultValues"
                 "/aws/lambda/Clusterpool"))

         (defun axe-logs-describe-log-groups-with-comp ()
           "Describe aws logs with compleation from AXE-LOGS-LOG-GROUPS-PREFIX."
           (interactive)
           (let ((prefix (completing-read "Prefix: " axe-logs-log-groups-prefix)))
             (axe-logs-describe-log-groups prefix :auto-follow nil)))
        
         (evil-leader/set-key "cl" 'axe-logs-describe-log-groups-with-comp))
   #+end_src
  
** Email
*** Gnus
    #+begin_src emacs-lisp
    (use-package gnus
    :config
  (setq user-mail-address "daniel.dpettersson.net@gmail.com"
        user-full-name "Daniel Pettersson")

  (setq gnus-select-method
        '(nnimap "gmail"
                 (nnimap-address "imap.gmail.com")
                 (nnimap-server-port "imaps")
                 (nnimap-stream ssl)))

  (setq smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")
  )
    #+end_src

*** Mu4e
    #+begin_src emacs-lisp
     (use-package mu4e
        :ensure nil
        :load-path "/usr/local/Cellar/mu/1.4.13/share/emacs/site-lisp/mu/mu4e/"
        :config

        ;(setq mu4e-mu-binary "/usr/local/Cellar/mu/1.4.13/mu")
        ;; default
        (setq mu4e-maildir (expand-file-name "~/Mail"))

        (setq mu4e-drafts-folder "/[Gmail].Drafts")
        (setq mu4e-sent-folder   "/[Gmail].Sent Mail")
        (setq mu4e-trash-folder  "/[Gmail].Trash")

        (setq mu4e-sent-messages-behavior 'delete)

        (setq mu4e-maildir-shortcuts
              '(("/INBOX"             . ?i)
                ("/[Gmail].Sent Mail" . ?s)
                ("/[Gmail].Trash"     . ?t)))

        ;; allow for updating mail using 'U' in the main view:
        (setq mu4e-get-mail-command "mbsync -a")

        (setq user-mail-address "daniel@dpettersson.net"
              user-full-name "Daniel Pettersson"))
    #+end_src

    
