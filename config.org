#+TITLE: Emacs configuration file
#+PROPERTY: header-args :results silent

* Setup init.el
#+begin_src emacs-lisp
  ;;; -*- lexical-binding: t -*-
#+end_src

* Package
Bootstrap =straight= and setup =use-package=.
#+begin_src emacs-lisp
  (require 'use-package)
  (use-package straight
    :custom
    ;; `straight' and `package' is not compatible
    (package-enable-at-startup nil)
    :init
    (defvar bootstrap-version)
    (let ((bootstrap-file
           (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
          (bootstrap-version 5))
      (unless (file-exists-p bootstrap-file)
        (with-current-buffer
            (url-retrieve-synchronously
             "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
             'silent 'inhibit-cookies)
          (goto-char (point-max))
          (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))
    (straight-use-package 'use-package)
    (straight-use-package 'el-patch))
#+end_src

=straight= does not respect package dependencies and their versions,
which is somewhat painful so I would like to replace it.

Unfortunately the now builtin =package-vc-install=, does not keep
"installed" packages under vc which makes version management and local
development a pain.  Other alternatives like =borg= might be a better
choice.

* General
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    ;; No bell
    (ring-bell-function 'ignore)
    ;; Follow symlinks
    (vc-follow-symlinks t)
    ;; Backup trails is worse then chem-trails
    (make-backup-files nil)
    (auto-save-default nil)
    ;; y/n will do
    (use-short-answers t)
    ;; Keep buffers fresh with `revert-buffer'
    (global-auto-revert-mode 1)
    ;; Ensure home is $HOME
    (default-directory "~/"))
#+end_src

* Looks
** Load theme
Load last =consult-theme= loaded theme.
#+begin_src emacs-lisp
  (use-package theme-load-last
    :after savehist
    :preface
    (defun load-last-theme ()
      (when (and consult--theme-history)
        (dolist (theme custom-enabled-themes)
          (disable-theme theme))
        (load-theme (intern (car consult--theme-history)) t)))
    :hook
    (savehist-mode . load-last-theme))
#+end_src

** Font
#+begin_src emacs-lisp
  (let ((width (display-pixel-width)))
    (set-frame-font
     (format "Comic Code Ligatures %d"
             (cond ((> width 1080) 14)
                   (t 12)))
     nil t))
#+end_src

** Themes
#+begin_src emacs-lisp
  (use-package ef-themes :straight t)
  (use-package standard-themes :straight t)
  (use-package zenburn-theme
    :straight t
    :custom
    (zenburn-override-colors-alist
     '(("zenburn-bg" . "#111111"))))
#+end_src

** Simplify UI
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    ;; Stop the incessant blinking
    (blink-cursor-mode nil)
    ;; Remove the bars
    (tool-bar-mode nil)
    (scroll-bar-mode nil)
    (menu-bar-mode nil))
#+end_src

** Opacity
#+begin_src emacs-lisp
  ;; Set current frames opacity
  (set-frame-parameter (selected-frame) 'alpha '95)
  ;; Set future frames
  (add-to-list 'default-frame-alist '(alpha 95))
#+end_src

** Mode-line
#+begin_src emacs-lisp
  (use-package emacs
    :straight nil
    :preface
    (defvar-local mode-line-file-path-cache nil)
    (defun mode-line-file-path-1 (file-name)
      (propertize
       (abbreviate-file-name
        (if-let* ((project-current (project-current))
                  (project (project-root project-current))
                  (project-parent
                   (thread-first project
                                 expand-file-name
                                 directory-file-name
                                 file-name-directory))
                  (relative-path
                   (file-relative-name (file-name-directory buffer-file-truename)
                                       project-parent)))
            (if (length< relative-path 40)
                relative-path
              (cl-loop with (root . rest) =
                       (file-name-split relative-path)
                       for p in rest
                       unless (string-empty-p p) collect
                       (substring p 0 1) into rest-short
                       finally return
                       (file-name-as-directory
                        (apply 'file-name-concat root rest-short))))
          default-directory))
       'help-echo (file-name-directory file-name)))

    (defun mode-line-file-path ()
      (when-let ((file-name (buffer-file-name)))
        (pcase-let ((`(,key ,path) mode-line-file-path-cache))
          (unless (eq default-directory key)
            (setq path (mode-line-file-path-1 file-name)
                  mode-line-file-path-cache `(,default-directory ,path)))
          path)))
    :custom
    (mode-line-position-column-line-format '(" %l:%c"))
    (column-number-mode 1)
    (mode-line-format
     '("%e" mode-line-front-space
       (:propertize
        ("" mode-line-mule-info mode-line-client mode-line-modified
         mode-line-remote mode-line-window-dedicated)
        display (min-width (5.0)))
       mode-line-frame-identification
       " "
       (:eval (mode-line-file-path))
       mode-line-buffer-identification
       "  "
       mode-line-position
       " "
       (:propertize mode-name face bold)
       mode-line-process
       "  "
       (vc-mode vc-mode)
       " "
       (:eval (when (buffer-narrowed-p)
                (propertize " Nar"
                            'face 'font-lock-warning-face)))
       (:eval (when (region-active-p)
                (format " Lines %d"
                        (1+ (evil-count-lines (region-beginning)
                                              (region-end))))))
       (defining-kbd-macro mode-line-defining-kbd-macro)
       " "
       mode-line-misc-info
       mode-line-format-right-align)))
#+end_src

** Dashboard - Splash screen
#+begin_src emacs-lisp
  (use-package dashboard
    :straight t
    :custom
    (dashboard-items '((recents  . 10)
                       (bookmarks . 10)))
    (dashboard-startup-banner
     (locate-user-emacs-file "xemacs_color.svg"))
    :config
    (dashboard-setup-startup-hook))
#+end_src

** MacOS
#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t)))
#+end_src

* Keymaps
** MacOS - System
#+begin_src emacs-lisp
  (use-package ns-win
    :if (eq system-type 'darwin)
    :custom
    (mac-option-key-is-meta t)
    (mac-right-option-modifier nil))
#+end_src

** Globla mappings
#+begin_src emacs-lisp
  (use-package emacs
    :config
    ;; HACK: To seperate C-i with <tab> in terminal <Tab> is more important then C-i
    (when (display-graphic-p)
      (define-key input-decode-map (kbd "C-i") (kbd "H-i"))))
#+end_src

** Meta - History insertion
Add non meta binding for history one of the most important Emacs
mappings.
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (define-key key-translation-map (kbd "C-.") (kbd "M-n"))
    (define-key key-translation-map (kbd "C-,") (kbd "M-p"))
    ;; Move cursor after inserted history
    (advice-add 'goto-history-element :after
                (lambda (&rest _) (end-of-buffer))))
#+end_src

** Repeat - Ergonomic keymaps
#+begin_src emacs-lisp
  (use-package repeat
    :custom
    (repeat-mode 1))
#+end_src

** Which Key - Discover bindings
#+begin_src emacs-lisp
  (use-package which-key
    :custom
    ;; Why wait?
    (which-key-idle-delay 1.)
    ;; Easier to see unbound keys
    (which-key-sort-order 'which-key-key-order-alpha)
    ;; On
    (which-key-mode +1))
#+end_src

** General - Leader and =:general=
#+begin_src emacs-lisp
  (use-package general
    :straight t
    :after evil
    :hook (after-init
           . (lambda ()
               (dolist (buffer (buffer-list))
                 (with-current-buffer buffer
                   (evil-normalize-keymaps)))))
    :config
    (general-create-definer leader-map
      :prefix "SPC"
      :states '(normal emacs motion visual)
      :keymaps 'override))
#+end_src

** Evil and Friends - Vi emulation
#+begin_src emacs-lisp
  ;; Last known good commit 30ebe6d:
  ;; - evil-escape macro bug (inserts "jK")
  ;; - minibuffer bug does not enter in insert mode
  (use-package evil
    :straight t
    :custom
    (evil-want-integration t)
    (evil-want-keybinding nil)
    (evil-want-C-i-jump nil)
    (evil-want-C-u-scroll t)
    (evil-want-minibuffer t)
    ;; Cursor type is enough for evil state
    (evil-mode-line-format nil)
    ;; Integrations
    (evil-undo-system 'undo-redo)
    ;; Follow windows on split)
    (evil-split-window-below t)
    (evil-vsplit-window-right t)
    :init
    ;; For some reason cannot be set with `:custom'
    (setq evil-search-module 'evil-search)
    :config
    ;; Use symbols instead of words when using the vim subject "word"
    (defalias #'forward-evil-word #'forward-evil-symbol)
    (setq-default evil-symbol-word-search t)

    ;; Run the macro in the q register
    (evil-define-key 'normal 'global "Q" "@q")

    ;; Keep eldoc on mode change
    (eldoc-add-command 'evil-insert)
    (eldoc-add-command 'evil-change)
    (eldoc-add-command 'evil-normal-state)
    (setq evil-insert-state-message nil
          evil-normal-state-message nil)

    ;; Common EX misspellings
    (evil-ex-define-cmd "E[dit]" 'evil-edit)
    (evil-ex-define-cmd "W[rite]" 'evil-write)
    (evil-ex-define-cmd "Wq" 'evil-save-and-close)
    (evil-ex-define-cmd "WQ" 'evil-save-and-close)

    ;; Fix bindings in messages buffer
    (with-current-buffer "*Messages*"
      (evil-normalize-keymaps))

    ;; Go
    (evil-mode t))
#+end_src

Almost as important as =evil= itself.
#+begin_src emacs-lisp
  (use-package evil-escape
    :straight t
    :custom
    (evil-escape-delay 0.1)
    (evil-escape-key-sequence "jk")
    (evil-escape-unordered-key-sequence t)
    :config
    (evil-escape-mode))
#+end_src

This makes =evil= almost feel like the default bindings.
#+begin_src emacs-lisp
  (use-package evil-collection
    :straight t
    :config
    ;; Setup `eshell' and `corfu' on there own
    (dolist (mode '(eshell corfu))
      (setq evil-collection-mode-list
            (delete mode evil-collection-mode-list)))
    (evil-collection-init))
#+end_src

Have always used Tims plugin.
#+begin_src emacs-lisp
  (use-package evil-surround
    :straight t
    :custom
    (global-evil-surround-mode +1))
#+end_src

** Embark - At "thing" mappings
#+begin_src emacs-lisp
  (use-package embark
    :straight t
    :preface
    (defun project-find-file-at (directory)
      "Visit a file in the current project."
      (let ((default-directory directory))
        (call-interactively 'project-find-file)))
    (defun find-file-at (directory)
      "Visit a file."
      (let ((default-directory directory))
        (call-interactively 'find-file)))
    :general
    (minibuffer-local-map
     :states '(insert normal)
     (kbd "C-SPC") 'embark-act
     (kbd "C-@") 'embark-act ;; In terminal C-@ -> {C-SPC,C-S-SPC}
     (kbd "C-<return>") 'embark-export)
    (:states
     'normal
     (kbd "C-SPC") 'embark-act)
    (embark-file-map
     "SPC" 'project-find-file-at
     "g" 'magit
     "G" 'consult-ripgrep
     "!" 'async-shell-command
     "e" 'eshell
     "." 'find-file-at
     "&" nil
     "$" nil)
    :custom
    ;; Show Embark actions via which-key
    (embark-action-indicator
     (lambda (map)
       (which-key--show-keymap "Embark" map nil nil 'no-paging)
       #'which-key--hide-popup-ignore-command)
     embark-become-indicator embark-action-indicator)
    :config
    ;; Remove C-u arg why would I want a new buffer?
    (setq embark-pre-action-hooks
     (thread-last embark-pre-action-hooks
                  (assoc-delete-all 'shell)
                  (assoc-delete-all 'eshell)))
    ;; Make magit usable by file category
    (add-to-list 'embark-around-action-hooks '(magit embark--cd)))
#+end_src
* Editing
** Jinx - Spellchecker
#+begin_src emacs-lisp
  (use-package jinx
    :after vertico
    :straight t
    :general
    (:states '(normal visual) "z=" #'jinx-correct)
    :hook
    (prog-mode . jinx-mode)
    (text-mode . jinx-mode)
    :custom
    (jinx-languages "en_US")
    :config
    ;; Git commit message improvements
    (add-to-list 'jinx-exclude-faces
                 '(text-mode
                   font-lock-comment-face
                   git-commit-comment-heading
                   git-commit-comment-branch-local
                   git-commit-comment-branch-remote
                   git-commit-comment-file))
    ;; Remove spell spell checking in string
    (add-to-list 'jinx-include-faces
                 '(prog-mode font-lock-comment-face
                             font-lock-doc-face))
    ;; Use grid for jinx completions
    (add-to-list 'vertico-multiform-categories
                 '(jinx grid (vertico-grid-annotate . 20))))
#+end_src

** Auto Fill - Auto break lines "long" lines
#+begin_src emacs-lisp
  (use-package simple
    :hook
    (text-mode . auto-fill-mode)
    (mail-mode . auto-fill-mode)
    (message-mode . auto-fill-mode)
    (prog-mode . auto-fill-mode)
    (prog-mode
     ;; Comments are re-used some mode which leads to `auto-fill' being
     ;; disabled where it should not `prog-mode'.
     . (lambda ()
         (setq-local comment-auto-fill-only-comments t)))
    :custom
    ;; No tabs please
    (indent-tabs-mode nil))
#+end_src

** Whitespace - Visualize white space, tabs, trailing and "long" lines
#+begin_src emacs-lisp
  (use-package whitespace
    :hook
    (prog-mode . whitespace-mode)
    (text-mode . whitespace-mode)
    :custom
    ;; Show "long" lines
    (whitespace-line-column 80)
    ;; Show "hidden" chars
    (whitespace-style '(face trailing lines-char tabs)))
#+end_src

** Whitespace Cleanup - Remove whitespace on save-buffer
#+begin_src emacs-lisp
  (use-package whitespace-cleanup-mode
    :straight t
    :hook
    (prog-mode . whitespace-cleanup-mode))
#+end_src

** Narrowing
#+begin_src emacs-lisp
  ;; Stolen from someplace
  (use-package narrow-or-widen
    :preface
    (defun narrow-or-widen-dwim ()
      "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first.  Narrowing to
  org-src-block actually calls `org-edit-src-code'."
      (interactive)
      (cond ((and (buffer-narrowed-p)) (widen))
            ((region-active-p)
             (narrow-to-region (region-beginning)
                               (region-end)))
            ((derived-mode-p 'org-mode)
             ;; `org-edit-src-code' is not a real narrowing
             ;; command. Remove this first conditional if
             ;; you don't want it.
             (cond ((ignore-errors (org-edit-src-code) t))
                   ((ignore-errors (org-narrow-to-block) t))
                   (t (org-narrow-to-subtree))))
            ((not (thing-at-point 'defun)) (narrow-to-page))
            (t (narrow-to-defun))))
    :general
    (leader-map "z" 'narrow-or-widen-dwim))
#+end_src

** Wgrep - Editing in "search" buffers
#+begin_src emacs-lisp
  (use-package wgrep :straight t)
#+end_src

** Tempel - Templates
Not convinced that it's more better then =yasnippet=.
#+begin_src emacs-lisp
  (use-package tempel
    :straight t
    :general
    (tempel-map
     "TAB" 'tempel-or-corfu-complete-next
     "<tab>" 'tempel-or-corfu-complete-next
     "<backtab>" 'tempel-previous
     "S-TAB" 'tempel-previous)
    :hook
    (evil-insert-state-exit . tempel-done)
    (eshell-mode . tempel-setup-capf)
    (prog-mode . tempel-setup-capf)
    (text-mode . tempel-setup-capf)
    :preface
    (defun tempel-setup-capf ()
      (setq-local completion-at-point-functions
                  (cons #'tempel-complete
                        completion-at-point-functions)))

    (defun tempel-or-corfu-complete-next ()
      (interactive)
      (if completion-in-region-mode
          (call-interactively 'corfu-complete)
        (call-interactively 'tempel-next)))
    :custom
    (tempel-trigger-prefix "!"))
#+end_src

* Completion
** General
#+begin_src emacs-lisp
  ;; Let bin be...
  (delete ".bin" completion-ignored-extensions)
  ;; Don't for case
  (setq completion-ignore-case t)
#+end_src

** Savehist - Save completion history
#+begin_src emacs-lisp
  (use-package savehist
    :custom
    (savehist-mode +1))
#+end_src

** Minibuffer - Read and complete
Hook for inserting current region into minibuffer for set of commands.
#+begin_src emacs-lisp
  (use-package minibuffer
    :hook
    (minibuffer-setup . minibuffer-insert-selection)
    :preface
    (defvar minibuffer-insert-region-commands
     '(consult-line
       consult-grep
       consult-ripgrep
       consult-lsp-symbols
       consult-eglot-symbols
       async-shell-command
       project-async-shell-command))
    (defun minibuffer-insert-selection ()
      "If region is active insert region into minibuffer."
      (when-let* ((_ (member this-command minibuffer-insert-region-commands))
                  (minibuffer-buffer (current-buffer))
                  (buffers (buffer-list))
                  (last-used-buffer (cadr buffers)))
        (with-current-buffer last-used-buffer
          (when (use-region-p)
            (let ((selection
                   (buffer-substring-no-properties
                (region-beginning) (region-end))))
              (setq mark-active nil)
              (with-current-buffer minibuffer-buffer
                (insert selection))))))))
#+end_src

** Vertico - Vertical minibuffer completion
#+begin_src emacs-lisp
  (use-package vertico
    :straight t
    :general
    (vertico-map
     :states '(insert normal)
     (kbd "RET") 'vertico-exit
     (kbd "C-n") 'vertico-next
     (kbd "C-p") 'vertico-previous)
    :custom
    (vertico-cycle t)
    (enable-recursive-minibuffers nil)
    (vertico-mode 1)
    :config
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator))

  (use-package vertico-directory
    :after vertico
    :straight nil
    :general
    (vertico-map "DEL" 'vertico-directory-delete-char
                 "M-DEL" 'vertico-directory-delete-word)
    :hook
    (rfn-eshadow-update-overlay . vertico-directory-tidy))

  (use-package vertico-multiform
    :after vertico
    :straight nil
    :custom
    (vertico-multiform-commands
     '((consult-ripgrep buffer)))
    :config
    (vertico-multiform-mode))
#+end_src

** Orderless - Completion style
#+begin_src emacs-lisp
  (use-package orderless
    :straight t
    :hook
    (minibuffer-setup . orderless-minibuffer-setup)
    :custom
    ;; use bang(!) to filter out candidates
    (orderless-style-dispatchers '(orderless-bang-filter))
    ;; default styles
    (completion-styles '(basic orderless))
    (completion-category-defaults nil)
    ;; setup style based on category
    (completion-category-overrides
     '(;; basic/partial makes more sense for files
       (file (styles basic partial-completion))
       (lsp-capf (styles basic))
       ;; for code completion use flex for sensible order
       (eglot (styles flex orderless))
       (eglot-capf (styles flex orderless))))
    :preface
    (defun orderless-minibuffer-setup ()
      (setq-local completion-styles '(orderless basic)))

    (defun orderless-bang-filter (pattern _index _total)
      (cond
       ((equal "!" pattern) '(orderless-literal . ""))
       ((string-prefix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 1))))))
#+end_src

** Consult - Improved candidate completion functions
#+begin_src emacs-lisp
  (use-package embark-consult
    :straight t)

  (use-package consult
    :straight t
    :preface
    (defun consult-kill-line-insert-history ()
      (interactive)
      (goto-char (point-max))
      (ignore-errors (call-interactively 'move-beginning-of-line) t)
      (ignore-errors (call-interactively 'kill-line) t)
      (call-interactively 'consult-history)
      (evil-insert-state))
    :general
    (leader-map
      "." 'find-file
      ":" 'execute-extended-command
      "s" 'consult-line
      "i" 'consult-imenu
      "b" 'consult-buffer
      "y" 'consult-yank-pop
      "!" 'async-shell-command
      "j" '(:which-key "jump")
      "jc" 'consult-compile-error
      "jf" 'consult-flymake
      "jm" 'consult-mark
      "h" '(:which-key "help")
      "hh" 'describe-function
      "hv" 'describe-variable)
    (minibuffer-local-map
     :states '(insert normal)
     (kbd "C-r") 'consult-history)
    (:keymaps '(comint-mode-map eshell-mode-map)
              :states '(insert normal)
              (kbd "C-r") 'consult-kill-line-insert-history)
    :custom
    (xref-show-xrefs-function 'consult-xref)
    (xref-show-definitions-function 'consult-xref)
    (consult-async-split-style 'semicolon)
    :hook
    (minibuffer-mode
     . (lambda (&rest _)
         (setq-local completion-in-region-function
                     (lambda (&rest args)
                       (apply (if vertico-mode
                                  #'consult-completion-in-region
                                #'completion--in-region)
                              args)))))
    :config
    ;; Easy access to replish buffers
    (defvar consult-repl-buffer-alist
      '(("*ielm*"       . ielm)
        ("*Python*"     . run-python)
        ("*nodejs*"     . nodejs-repl)
        ("*SQL: SQLite" . sql-sqlite)))
    (add-to-list
     'consult-buffer-sources
     `( :name     "REPL"
        :hidden   nil
        :narrow   ?r
        :category buffer
        :state    consult--buffer-state
        :history  buffer-name-history
        :action   ,(lambda (key)
                     (funcall (alist-get key consult-repl-buffer-alist)))
        :items    ,(lambda ()
                     (mapcar #'car consult-repl-buffer-alist)))
     'append)

    ;; do not preview buffers in consult-buffer
    (consult-customize consult-buffer :preview-key nil))
#+end_src

** Marginalia - Minibuffer annotations
#+begin_src emacs-lisp
  (use-package marginalia
    :straight t
    :custom
    (marginalia-mode +1))
#+end_src

** Corfu - Completion in region function
#+begin_src emacs-lisp
  (use-package corfu
    :straight t
    :general
    (corfu-map "RET" nil)
    (corfu-map :states 'insert
               (kbd "C-n") 'corfu-next
               (kbd "C-p") 'corfu-previous
               (kbd "C-SPC") #'corfu-move-to-minibuffer)
    :hook
    (evil-insert-state-exit . corfu-quit)
    (eshell-mode
     . (lambda ()
         (setq-local corfu-auto nil)
         (corfu-mode)))
    :custom
    (corfu-cycle t)
    (corfu-preview-current nil)
    (corfu-auto t)
    (corfu-preselect 'first)
    (corfu-quit-no-match t)
    (corfu-auto-prefix 2)
    (corfu-on-exact-match 'quit)
    ;; Orderless completion
    (corfu-separator ?s)
    (corfu-quit-at-boundary nil)
    ;; In eshell use tab to open corfu
    (corfu-excluded-modes '(eshell-mode))
    ;; Stay out of minibuffer
    (global-corfu-minibuffer nil)
    (global-corfu-mode 1)
    :config
    (defun corfu-move-to-minibuffer ()
      (interactive)
      (pcase completion-in-region--data
        (`(,beg ,end ,table ,pred ,extras)
         (let ((completion-extra-properties extras)
               completion-cycle-threshold completion-cycling)
           (consult-completion-in-region beg end table pred)))))
    (add-to-list 'corfu-continue-commands #'corfu-move-to-minibuffer)
    ;; C-n C-p needs some hacking to override evil binding
    (evil-make-overriding-map corfu-map)
    (advice-add 'corfu--setup :after
                (lambda (&rest _) (evil-normalize-keymaps)))
    (advice-add 'corfu--teardown :after
                (lambda (&rest _) (evil-normalize-keymaps))))

  (use-package corfu-popupinfo ;; packaged with corfu
    :custom
    (corfu-popupinfo-delay '(0.5 . 0.0))
    (corfu-popupinfo-mode 1))

  (use-package corfu-history ;; packaged with corfu
    :custom
    (corfu-history-mode 1))

  (use-package corfu-terminal
    :if (not (display-graphic-p))
    :straight t
    :custom
    (corfu-terminal-mode +1))
#+end_src

** Cape - Completion at point functions
#+begin_src emacs-lisp
  (use-package cape
    :straight t
    :hook
    (lsp-mode
     . (lambda ()
         (setq-local completion-at-point-functions
                     (list 'tempel-complete
                           (cape-capf-super #'lsp-completion-at-point)
                           'cape-file))))
    (eglot-managed-mode
     . (lambda ()
         (setq-local completion-at-point-functions
                     (list 'tempel-complete
                           'cape-file
                           (cape-capf-super 'eglot-completion-at-point)))))
    :config
    ;; Default completion at point additions
    (add-to-list 'completion-at-point-functions #'cape-history)
    (add-to-list 'completion-at-point-functions #'cape-file))
#+end_src

* Default directory
** Projects - Project
#+begin_src emacs-lisp
  ;; Last working commit bf4c3cf after that the history is broken
  (use-package project
    :after consult ;; ripgrep
    :general
    (leader-map
      "SPC" 'project-find-file
      "p" '(:which-key "project")
      "pp" 'project-switch-project
      "pc" 'project-compile
      "pC" 'project-recompile
      "p!" 'project-async-shell-command
      "pd" 'project-dired
      "pe" 'project-eshell
      "pg" 'consult-ripgrep)
    :custom
    (project-vc-extra-root-markers '(".projectile" ".project"))
    (project-switch-commands 'project-find-file)
    :config
    ;; Remove current visited file from list
    (cl-defun project-advice-read-file-filter
        ((prompt all-files . args))
      (when buffer-file-name
        (setq all-files
              (delete
               (thread-last (project-current)
                            (project-root)
                            (file-relative-name buffer-file-name))
               all-files)))
      `(,prompt ,all-files ,@args))
    (advice-add 'project--read-file-cpd-relative :filter-args
                #'project-advice-read-file-filter)

    ;; Ensure that embark works (embark--cd)
    (defun project-switch-project-advice (project-switch-project dir)
      (minibuffer-with-setup-hook
          (lambda () (setq default-directory dir))
        (funcall project-switch-project dir)))
    (advice-add 'project-switch-project :around
                #'project-switch-project-advice))
#+end_src

** Change directory - Consult dir
#+begin_src emacs-lisp
  (use-package consult-dir
    :general
    ;; Insert directory into minibuffer
    (minibuffer-mode-map
     :states '(normal insert)
     (kbd "C-f") #'consult-insert-directory)
    ;; Dispatch on directory
    (leader-map "f" #'consult-dir)
    :preface
    (defun consult-read-directory (prompt)
      "Read consult directory."
      (let ((sources
             '(("Projects" ?p
                (lambda ()
                  (project--ensure-read-project-list)
                  (cl-loop for (path) in project--list
                           collect path)))
               ("Open" ?o
                (lambda ()
                  (cl-loop
                   with folder-modes = '(dired-mode eshell-mode)
                   for buffer in (buffer-list)
                   for mode = (with-current-buffer buffer major-mode)
                   when (provided-mode-derived-p mode folder-modes)
                   collect (with-current-buffer buffer default-directory))))
               ("Bookmarks" ?m
                (lambda ()
                  (cl-loop for (_ . params) in bookmark-alist
                           for path = (alist-get 'filename params)
                           when (and (stringp path) (directory-name-p path))
                           collect path)))
               ("Recentf" ?f
                (lambda ()
                  (cl-loop for filename in recentf-list
                           collect (file-name-directory filename)))))))
        (car
         (consult--multi
          (cl-loop for (name narrow fn) in sources
                   collect (list
                            :name name
                            :narrow narrow
                            :items fn
                            :category 'file))
          :prompt prompt))))

    (defun consult-dir (directory)
      "Dispatch on DIRECTORY."
      (interactive
       (list (consult-read-directory "Dispatch on directory: ")))
      (let* ((directory (expand-file-name directory))
             (default-directory directory))
        (cond
         ((ignore-errors (project-current))
          (funcall-interactively 'project-find-file))
         (t (dired directory)))))

    (defun consult-insert-directory (directory)
      "Insert DIRECTORY."
      (interactive
       (list
        (let ((enable-recursive-minibuffers t))
          (consult-read-directory "Insert directory: "))))
      (insert (expand-file-name directory))))

#+end_src

* Window and frames
** Window
#+begin_src emacs-lisp
  (use-package window
    :custom
    ;; Use more space for right and left *side* windows
    (window-sides-vertical t)
    ;; Display buffer rules
    (display-buffer-alist
     `(;; Pop from below
       ((or
         ;; Output
         (derived-mode . shell-command-mode)
         (derived-mode . messages-buffer-mode)
         (derived-mode . backtrace-mode)
         ;; Org capture
         "\\(\\*Capture\\*\\|CAPTURE-.*\\)"
         ;; Result buffers
         "\\*Embark Export: .*\\*"
         (derived-mode . embark-collect-mode)
         (derived-mode . occur-mode)
         (derived-mode . ibuffer-mode)
         (derived-mode . grep-mode)
         (derived-mode . xref--xref-buffer-mode)
         (derived-mode . flymake-project-diagnostics-mode)
         (derived-mode . flymake-diagnostics-buffer-mode))
        (display-buffer-reuse-window display-buffer-below-selected)
        (body-function . select-window)
        (dedicated . t))
       ;; Pop from right
       ((or
         ;; Help buffers
         (derived-mode . help-mode)
         (derived-mode . Man-mode)
         (derived-mode . devdocs-mode)
         (derived-mode . shortdoc-mode)
         "\\*eldoc.*\\*")
        (display-buffer-in-direction)
        (direction . rightmost)
        (window-width . 80)
        (dedicated . t)
        (body-function . select-window))
       ;; Org select
       ("\\*Org \\(Select\\|Note\\)\\*"
        (display-buffer-in-side-window)
        (dedicated . t)
        (side . bottom)
        (slot . 0)
        (window-parameters . ((mode-line-format . none))))
       ;; Magit
       ((or (derived-mode . magit-diff-mode)
            (derived-mode . magit-process-mode))
        (display-buffer-pop-up-window))
       ((derived-mode . magit-status-mode)
        (display-buffer-same-window)))))
#+end_src

** Frame
#+begin_src emacs-lisp
  (use-package frame
    :general
    (leader-map
      "w" '(:ignore t :which-key "windows and frames")
      "wt" 'toggle-frame-maximized
      "wm" 'toggle-frame-fullscreen)
    :custom
    (frame-resize-pixelwise t))
#+end_src

** Evil lazy window switching
#+begin_src emacs-lisp
  (use-package evil-lazy-bindings
    :general
    (general-def general-override-mode-map
      :states '(normal insert)
      "C-j" 'evil-window-down
      "C-k" 'evil-window-up
      "C-h" 'evil-window-left
      "C-l" 'evil-window-right))
#+end_src

** Tab-bar
#+begin_src emacs-lisp
  (use-package tab-bar
    :general
    (leader-map
      "tr" 'tab-bar-rename-tab
      "tn" 'tab-bar-new-tab
      "tk" 'tab-bar-close-tab)
    :custom
    (tab-bar-format
     '(tab-bar-format-tabs tab-bar-format-align-right tab-bar-format-global))
    (tab-bar-tab-name-function 'tab-bar-tab-name-all)
    (tab-bar-close-button-show nil)
    (tab-bar-show t)
    (tab-bar-tab-hints t)
    (tab-bar-mode +1)
    (tab-bar-select-tab-modifiers '(super)))
#+end_src

** Ace Window - Select window
#+begin_src emacs-lisp
  (use-package ace-window
    :straight t
    :general
    (leader-map "jw" 'ace-window)
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+end_src

** Dedicated windows
#+begin_src emacs-lisp
  (use-package dedicated-window
    :general
    (leader-map
      "wd" 'toggle-window-dedicated
      "wq" 'kill-dedicated-windows)
    :preface
    (defun toggle-window-dedicated ()
      "Toggle window dedicated."
      (interactive)
      (set-window-dedicated-p (selected-window)
                              (not (window-dedicated-p)))
      (force-mode-line-update t))

    (defun kill-dedicated-windows ()
      "Kill all dedicated windows."
      (interactive)
      (cl-loop
       for window in (window-list)
       when (window-dedicated-p window) do
       (quit-window nil window))))
#+end_src

* Buffer and navigation
** Recentf - Save buffer history
#+begin_src emacs-lisp
  (use-package recentf
    :custom
    (recentf-mode +1))
#+end_src

** Better Jumper - Move forwards/backwards in point history
#+begin_src emacs-lisp
  (use-package better-jumper
    :straight t
    :general
    (:states 'motion
             "C-o" 'better-jumper-jump-backward
             "H-i" 'better-jumper-jump-forward)
    :custom
    (better-jumper-mode +1))
#+end_src

** Avy - In buffer navigation
#+begin_src emacs-lisp
  (use-package avy
    :straight t
    :general
    (leader-map
      "jj" #'evil-avy-goto-char-timer
      "jl" #'evil-avy-goto-line-keep-column)
    :custom
    (avy-timeout-seconds 0.3)
    (avy-style 'de-bruijn)
    (avy-line-insert-style 'below)
    (avy-dispatch-alist '((?x . avy-action-kill-move)
                          (?X . avy-action-kill-stay)
                          (?v . avy-action-visual)
                          (?w . avy-action-copy)
                          (?p . avy-action-paste)
                          (?P . avy-action-paste-line)
                          (?z . avy-action-ispell)))
    (avy-all-windows 'all-frames)
    :preface
    (defun avy-goto-line-keep-column (&optional arg)
      "Jump to a line at the current column."
      (interactive "p")
      (let ((window (selected-window))
            (column (current-column)))
        (avy-goto-line arg)
        (when (equal window (selected-window))
          (move-to-column column))))

    (defun avy-action-visual (pt)
      (let (beg end)
        (goto-char pt)
        (setq beg (point))
        (avy-forward-item)
        (backward-char)
        (setq end (point))
        (evil-visual-select beg end)))

    (defun avy-action-paste-line (pt)
      (avy-action-yank-line pt))

    (defun avy-action-paste (pt)
      (avy-action-yank pt))
    :config
    (advice-add 'avy-read :before (lambda (&rest _) (avy-show-dispatch-help)))
    (advice-add 'avy-read-de-bruijn :before (lambda (&rest _) (avy-show-dispatch-help)))
    ;; Recognize goto line as an evil motion
    (evil-define-avy-motion avy-goto-line-keep-column line))
#+end_src

** Find-file - Find other (file)buffer
#+begin_src emacs-lisp
  (use-package find-file
    :general
    (leader-map
      "jq" 'ff-find-other-file
      "jQ" 'ff-find-other-file-other-window)
    :preface
    (defun ff-find-other-file-other-window ()
      "Find the header or source file."
      (interactive)
      (ff-find-other-file 'other-window)
      (xref-pulse-momentarily)))
#+end_src

* Shell and Commands
** Exec path from shell - Infer PATH
=exec-path-from-shell= is a hack to set `exec-path' shellishly for
Emacsen not launched from a shell.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :straight t
    :config
    (exec-path-from-shell-initialize))
#+end_src

** Eshell - The preferred non standard shell
#+begin_src emacs-lisp
  (use-package eshell
    :preface
    (defun evil-append-last-line (&rest _)
      "Set point to max and enter `evil-insert'."
      (interactive)
      (goto-char (point-max))
      (evil-append 1))

    (defun eshell-buffer-name ()
      (format "*eshell %s*" (abbreviate-file-name default-directory)))

    ;; Eshells prefix arg interface has never stuck.
    ;; `default-directory' instead and use `prefix-argument' / dwim
    ;; (current buffer `eshell-mode') to create a new buffer.
    (defun eshell-advice (eshell &rest args)
      "Create an Eshell buffer here."
      (interactive)
      (eshell-load-modules eshell-modules-list)
      (if (not (called-interactively-p 'any))
          (apply eshell args)
        ;; If `eshell' called interactively used current directory as
        ;; basis for buffer name.
        (let* ((eshell-buffer-name (eshell-buffer-name))
               (buffer (funcall eshell (or current-prefix-arg
                                           (derived-mode-p 'eshell-mode)))))
          (with-current-buffer buffer
            (add-hook 'eshell-directory-change-hook
                      (lambda () (rename-buffer (eshell-buffer-name) t))
                      nil t))
          buffer)))
    :hook
    (eshell-mode
     . (lambda ()
         ;; Add imenu support
         (setq-local imenu-generic-expression '(("$ " " $ \\(.*\\)" 1)))))
    :general
    (leader-map "e" 'eshell)
    (eshell-mode-map
     :states 'normal
     "C-p" 'eshell-previous-prompt
     "C-n" 'eshell-next-prompt
     "q" 'kill-current-buffer
     (kbd "<return>") 'evil-append-last-line)
    :custom
    (eshell-history-size 99999)
    (eshell-hist-ignoredups t)
    (eshell-save-history-on-exit t)
    :config
    ;; Setup eshell `default-directory' naming stuff
    (advice-add 'eshell :around #'eshell-advice)
    ;; Ensure that we are in insert mode
    (advice-add 'project-eshell :after #'evil-append-last-line)
    (advice-add 'eshell :after #'evil-append-last-line)
    ;; Cat works with eshell other pagers does not
    (setenv "PAGER" "cat")
    ;; Eshell command
    (defun eshell/ff (&rest args)
      (apply #'find-file args)))
#+end_src

Faces in =eshell= feels helpful.
#+begin_src emacs-lisp
  (use-package eshell-syntax-highlighting
    :straight t
    :config
    (eshell-syntax-highlighting-global-mode +1))
#+end_src

** EAT - Safe char based terminal apps
#+begin_src emacs-lisp
  (use-package eat
    :straight t
    :config
    (add-hook 'eshell-load-hook #'eat-eshell-mode))
#+end_src

** Compile - Run thing
#+begin_src emacs-lisp
  (use-package compile
    :custom
    ;; Use last history as the compile command
    (compile-command (or (car-safe compile-history) ""))
    ;; Always scroll
    (compilation-scroll-output t)
    ;; Just save me the keystrokes
    (compilation-ask-about-save nil)
    :config
    ;; Not compile specific, but strip ^M in comint buffers
    (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m))
#+end_src

Convert escape codes to color.
#+begin_src emacs-lisp
  (use-package xterm-color
    :straight t
    :preface
    (defun xterm-color-advice-compilation-filter (f proc string)
      (funcall f proc (xterm-color-filter string)))
    :custom
    (compilation-environment '("TERM=xterm-256color"))
    :config
    (advice-add 'compilation-filter :around #'xterm-color-advice-compilation-filter))
#+end_src

** Async Shell Command - Run things
#+begin_src emacs-lisp
  (use-package shell
    :preface
    ;; Show exit code in mode line
    (defun shell-command-sentinel-show-exit-code (process status)
      (when-let* ((buffer (process-buffer process))
                  ((buffer-live-p buffer)))
        (let ((dead-p (memq (process-status process) '(exit signal)))
              (status (process-exit-status process)))
          (with-current-buffer buffer
            (setq mode-line-process
                  (propertize
                   (concat
                    ":"
                    (format "%s" (process-status process))
                    (when dead-p
                      (format " [%s]" status)))
                   'face (if (zerop status) 'success 'warning)))
            (force-mode-line-update t)))))
    :general
    (leader-map "!" 'async-shell-command)
    (shell-command-mode-map
     :states 'normal
     "q" 'kill-current-buffer
     "gr" 'revert-buffer ;; reruns buffer
     "p" 'term-paste)
    :custom
    (async-shell-command-buffer 'rename-buffer)
    (shell-command-prompt-show-cwd t)
    :config
    ;; Bolt on char based input on evil insert mode,
    ;; `comint-send-input' breaks to often.
    (require 'term)
    (evil-set-auxiliary-keymap shell-command-mode-map
                               'insert (map-copy term-raw-map))
    (add-to-list 'evil-normal-state-modes 'shell-command-mode)

    (advice-add 'shell-command-sentinel :after
                #'shell-command-sentinel-show-exit-code))
#+end_src

** Recall - Run things again
#+begin_src emacs-lisp
  (use-package recall
    :straight (recall :type git :host github :repo "svaante/recall")
    :general
    (leader-map "r" 'recall-rerun)
    :custom
    (recall-mode +1)
    :config
    (evil-make-overriding-map recall-list-mode-map)
    (evil-make-overriding-map recall-log-mode-map))

#+end_src

* Org
** General
#+begin_src emacs-lisp
  (use-package org
    :hook
    (org-mode . org-indent-mode)
    (org-mode . visual-line-mode)
    ;; Looks
    (org-mode
     . (lambda ()
         (set-face-attribute 'org-level-1 nil :height 1.4)
         (set-face-attribute 'org-level-2 nil :height 1.2)
         (set-face-attribute 'org-level-3 nil :height 1.1)
         (set-face-attribute 'org-document-title nil :height 2.0)))
    :general
    (org-mode-map :states 'normal
                  (kbd "<RET>") 'org-return)
    (leader-map
      "o" '(:which-key "org")
      "os" 'org-store-link)
    :custom
    (org-imenu-depth 3)
    (org-src-window-setup 'current-window)
    (org-return-follows-link t)
    (org-startup-with-inline-images t))
#+end_src

** Org Agenda
#+begin_src emacs-lisp
  (use-package org-agenda
    :general
    (leader-map
      "oa" 'org-agenda-custom
      "ot" 'org-todo-list
      "ow" 'org-agenda-list)
    (org-agenda-mode-map
     :states 'normal
     (kbd "<RET>") 'org-agenda-goto
     "q" 'org-agenda-quit
     "t" 'org-agenda-todo
     "j" 'org-agenda-next-line
     "k" 'org-agenda-previous-line
     "n" 'org-agenda-later
     "p" 'org-agenda-earlier)
    :preface
    (defun org-agenda-custom ()
      "Org agenda custom view."
      (interactive)
      (org-agenda nil "A"))
    :custom
    ;; Don't make any assumption on how I want my windows
    (org-agenda-window-setup 'other-window)
    (org-agenda-breadcrumbs-separator " ")
    (org-agenda-prefix-format
     '((agenda .  "  %?-40 b")
       (todo .    "  %?-40 b")
       (tags .    "  %?-40 b")
       (search .  "  %?-40 b")))
    (org-todo-keywords
     '((sequence "TODO" "DONE")))
    ;; Replace the original agenda
    (org-agenda-custom-commands
     '(("A" "Agenda"
        ((agenda)
         (tags "+LEVEL=1-SCHEDULED={.+}-DEADLINE={.+}/TODO"
               ((org-agenda-overriding-header "Todos:")))
         (tags "-hide+LEVEL>1-SCHEDULED={.+}/TODO"
               ((org-agenda-overriding-header "Projects:")))))))
    (org-agenda-files '("~/org/notes.org"
                        "~/org/pad.org"
                        "~/org/todo.org"))
    :config
    (evil-set-initial-state 'org-agenda-mode 'normal))

#+end_src

** Org Capture
#+begin_src emacs-lisp
  (use-package org-capture
    :general
    (leader-map "oc" 'org-capture)
    :hook
    (org-capture-mode . evil-insert-state)
    :custom
    (org-refile-use-outline-path 'file)
    (org-refile-targets '((org-agenda-files :maxlevel . 3)))
    (org-outline-path-complete-in-steps nil)
    (org-capture-templates
     '(("t" "Todo" entry
        (file "~/org/todo.org")
        "* TODO %?\n%a")
       ("n" "Note" entry
        (file "~/org/notes.org")
        "* %?\n")
       ("p" "Pad" plain
        (file+olp+datetree "~/org/pad.org")
        "\n%?\n" :unnarrowed t :hook org-narrow-to-subtree))))
#+end_src

** Evil Org - Org keybinds
#+begin_src emacs-lisp
  (use-package evil-org
    :straight t
    :hook (org-mode . evil-org-mode)
    :custom
    (evil-org-key-theme
     '(textobjects insert return return
                   additional shift todo))
    :config
    ;; Seams off but `evil-org-set-key-theme' needs to be called if
    ;; themes change
    (evil-org-set-key-theme))
#+end_src

** Org Mono - Search and index Org headlines
#+begin_src emacs-lisp
  (use-package org-mono
    :straight (org-mono :type git :host github
                        :repo "svaante/org-mono")
    :general
    (leader-map "oo" 'org-mono-goto)
    :custom
    (org-mono-files (append org-agenda-files
                            '("~/.emacs.d/config.org")))
    (org-mono-advice-org-refile t)
    (global-org-mono-mode +1)
    :config
    (defvar-keymap embark-org-mono-actions-map
      :doc "Keymap for actions for org-mono."
      :parent embark-general-map
      "o" #'org-mono-goto-other-window
      "t" #'org-mono-todo
      "r" #'org-mono-rename
      "w" #'org-mono-refile-from
      "a" #'org-mono-archive
      "k" #'org-mono-delete-headline
      "c" #'org-mono-goto-headline-child
      "d" #'org-mono-time-stamp
      "b" #'org-mono-goto-backlinks)
    (add-to-list 'embark-keymap-alist '(org-mono . embark-org-mono-actions-map)))

  (use-package org-mono-consult
    :after org-mono
    :custom
    (org-mono-completing-read-fn 'org-mono-consult-completing-read))
#+end_src

* Programming
** General
*** Prog Mode - Basic keybinds
General bindings
#+begin_src emacs-lisp
  (use-package prog-mode
    :general
    (prog-mode-map :states 'visual (kbd "C-;") 'comment-dwim))
#+end_src

*** Eglot - Completions and stuff
#+begin_src emacs-lisp
  (use-package jsonrpc :straight t)

  (use-package lsp-snippet-tempel
    :straight (lsp-snippet-tempel :type git
                                  :host github
                                  :repo "svaante/lsp-snippet")
    :config
    (lsp-snippet-tempel-lsp-mode-init)
    (lsp-snippet-tempel-eglot-init))

  (use-package eglot
    :straight t
    :hook
    (c-mode . eglot-ensure)
    (c++-mode . eglot-ensure)
    (rust-mode . eglot-ensure)
    (javascript-mode . eglot-ensure)
    (typescript-mode . eglot-ensure)
    (go-mode . eglot-ensure)
    (python-mode . eglot-ensure)
    (csharp-mode . eglot-ensure)
    :general
    (leader-map
      "la" 'eglot-code-actions
      "lr" 'eglot-rename
      "lf" 'eglot-format-buffer
      "lq" 'eglot-code-action-quickfix
      "la" 'eglot-code-actions)
    :preface
    (defun eglot-imenu-keep-parent (alist)
      "Extract `eglot-imenu' keys as items from the imenu ALIST."
      (mapcan
       (pcase-lambda (`(,key . ,value))
         (cond
          ((listp value)
           `((,key . ,(car (get-text-property 0 'breadcrumb-region key)))
             (,key . ,(eglot-imenu-keep-parent value))))
          (t `((,key . ,value)))))
       alist))

    (defun eglot-imenu-extract-base-kind (alist)
      "Add kind as an parent to each item to PLIST."
      (mapcar (pcase-lambda (`(,key . ,value))
                (let ((kind (get-text-property 0 'breadcrumb-kind key)))
                  (cond
                   ((stringp kind)
                    (cons (concat kind) `((,key . ,value))))
                   (t `(,key . ,value)))))
              alist))
    :config
    ;; Keep parent in imenu
    (advice-add 'eglot-imenu :filter-return 'eglot-imenu-keep-parent)
    ;; Add type as imenu
    (advice-add 'eglot-imenu-keep-parent :filter-return 'eglot-imenu-extract-base-kind))

  (use-package consult-eglot
    :after eglot
    :straight t
    :general
    (leader-map "ls" 'consult-eglot-symbols))
#+end_src

*** LSP Mode - Completions and stuff
#+begin_src emacs-lisp
  (use-package lsp-mode
    :disabled
    :after lsp-snippet-tempel
    :straight t
    :general
    (leader-map "lr" 'lsp-rename)
    :hook
    (c-mode . lsp)
    (python-mode . lsp)
    (lsp-mode
     . (lambda ()
         (setq-local evil-lookup-func #'lsp-describe-thing-at-point)))
    :custom
    (lsp-headerline-breadcrumb-enable nil)
    (lsp-modeline-code-actions-enable nil)
    (lsp-modeline-diagnostics-enable nil)
    :config
    (lsp-snippet-tempel-lsp-mode-init))

  (use-package consult-lsp
    :after lsp-mode
    :straight t
    :general
    (leader-map "ls" 'consult-lsp-symbols))
#+end_src

*** Xref - Goto code thing
#+begin_src emacs-lisp
  (use-package xref
    :general
    (prog-mode-map
     :states 'normal
     "gr" 'xref-find-references
     "gD" 'xref-find-definitions-other-window)
    :custom
    ;; Do not prompt, just search
    (xref-prompt-for-identifier
     '(not xref-find-definitions
           xref-find-definitions-other-window
           xref-find-definitions-other-frame
           xref-find-references)))
#+end_src

*** Flymake - Show errors
#+begin_src emacs-lisp
  (use-package flymake
    :custom
    ;; I find the fringe bang's distracting
    (flymake-fringe-indicator-position nil)
    :hook
    (emacs-lisp-mode . flymake-mode))
#+end_src

*** Paren - Highlight parenthesis
#+begin_src emacs-lisp
  (use-package paren
    :custom
    (show-paren-style 'parenthesis)
    (show-paren-when-point-in-periphery nil)
    (show-paren-when-point-inside-paren nil)
    (show-paren-delay 0)
    (show-paren-mode +1))
#+end_src

*** Dape - Debug
#+begin_src emacs-lisp
  (use-package dape
    :straight (dape :type git :host github
                    :repo "svaante/dape")
    :preface
    (defun pulse-once ()
      (let ((pulse-iterations 1))
        (pulse-momentary-highlight-one-line)))
    (defun save-all-buffers ()
      (save-some-buffers t t))
    :general
    (dape-global-map
     (kbd "H-i") #'dape-stack-select-down
     (kbd "C-o") #'dape-stack-select-up)
    (leader-map
      "d" '(:keymap dape-global-map :which-key "dape"))
    :hook
    (kill-emacs . dape-breakpoint-save)
    (after-init . dape-breakpoint-load)
    (dape-display-source . pulse-once)
    (dape-compile . kill-buffer)
    :custom
    (dape-debug t)
    (dape-buffer-window-arrangment 'gud)
    (dape-info-hide-mode-line nil)
    (dape-inlay-hints t)
    ;; No trucation
    (dape-info-variable-table-row-config
     '((name . 0) (value . 0) (type . 0)))
    (dape-breakpoint-global-mode +1)
    :config
    (add-hook 'dape-start-hook #'save-all-buffers)
    ;; java ughhh
    (require 'eglot)
    (let ((jar
           (car
            (file-expand-wildcards
             (file-name-concat dape-adapter-dir
                               "java-debug"
                               "com.microsoft.java.debug.plugin"
                               "target"
                               "com.microsoft.java.debug.plugin-*.jar")
             t))))
      (add-to-list 'eglot-server-programs
                   `((java-mode java-ts-mode) .
                     ("jdtls"
                      :initializationOptions
                      (:bundles [,jar]))))))

  (use-package dape-cortex-debug
    :after dape
    :straight (dape-cortex-debug :type git :host github
                                 :repo "svaante/dape-cortex-debug")
    :config
    (require 'dape-cortex-debug))
#+end_src

*** Devdocs - Documentation
#+begin_src emacs-lisp
  (use-package devdocs
    :general
    (leader-map "k" 'devdocs-lookup)
    :straight t)
#+end_src

** Elisp
#+begin_src emacs-lisp
  (use-package elisp-mode
    :hook
    (emacs-lisp-mode
     . (lambda ()
         (setq-local evil-lookup-func
                     #'describe-elisp-thing-at-point)))
    :general
    (:keymaps
     '(emacs-lisp-mode-map lisp-interaction-mode-map)
     :states '(normal insert)
     (kbd "C-c C-e") 'eval-defun
     (kbd "C-c C-c") 'eval-buffer)
    (:keymaps
     '(emacs-lisp-mode-map lisp-interaction-mode-map)
     :states 'visual
     (kbd "C-c C-c") 'eval-region)
    :preface
    ;; Stolen from http://www.sugarshark.com/elisp/init/lisp.el.html
    (defun describe-elisp-thing-at-point ()
      "Show the documentation of the Elisp function and variable near point."
      (interactive)
      (let (sym)
        (cond
         ((setq sym
                (ignore-errors
                  (with-syntax-table emacs-lisp-mode-syntax-table
                    (save-excursion
                      (or (not (zerop (skip-syntax-backward "_w")))
                          (eq (char-syntax (char-after (point))) ?w)
                          (eq (char-syntax (char-after (point))) ?_)
                          (forward-sexp -1))
                      (skip-chars-forward "`'")
                      (let ((obj (read (current-buffer))))
                        (and (symbolp obj) (fboundp obj) obj))))))
          (describe-function sym))
         ((setq sym (variable-at-point)) (describe-variable sym))
         ((setq sym (function-at-point)) (describe-function sym))
         ((setq sym (symbol-at-point)) (describe-function sym))))))
#+end_src

*** Eros - Inlay eval
#+begin_src emacs-lisp
  (use-package eros
    :straight t
    :config
    (eros-mode))
#+end_src

*** Debug - It's more convinent then edebug
#+begin_src emacs-lisp
  (use-package debug
    :custom
    (debugger-stack-frame-as-list t))
#+end_src

** C
#+begin_src emacs-lisp
  (use-package cc-mode
    :hook (c-mode . (lambda () (setq-local tab-width 4)))
    :custom
    (c-basic-offset 4))
#+end_src

** Python
Manage environment with =pyenv=
#+begin_src emacs-lisp
  (use-package pyvenv
    :straight t
    :custom
    (pyvenv-mode +1))
#+end_src

** Rust
Why is =rust-mode= not part Emacs?
#+begin_src emacs-lisp
  (use-package rust-mode
    :straight t)
#+end_src

** Typescript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :straight t)
#+end_src

* Data files
#+begin_src emacs-lisp
  (use-package protobuf-mode :straight t)
  (use-package yaml-mode :straight t)
  (use-package json-mode :straight t)
  (use-package jenkinsfile-mode :straight t)
#+end_src

* Applications
** General
#+begin_src emacs-lisp
  (leader-map "a" '(:which-key "applications"))
#+end_src

** Magit - Version Control
#+begin_src emacs-lisp
  (use-package magit
    :straight t
    :general
    (leader-map
      "g" '(:which-key "magit")
      "gg" 'magit-status-here
      "g." 'magit-find-file
      "gd" 'magit-diff
      "gb" 'magit-blame
      "gl" 'magit-log
      "gc" 'magit-checkout
      "gf" 'magit-fetch-all
      "gf" 'magit-log-buffer-file)
    :custom
    ;; sort branches by checkout (completion)
    (magit-list-refs-sortby "-creatordate")
    ;; don't let magit close windows
    (magit-bury-buffer-function 'bury-buffer)
    ;; wrangle magits and its transient buffer to not create pop-up
    (magit-display-buffer-function 'display-buffer)
    (transient-display-buffer-action '(display-buffer-below-selected))
    (transient-mode-line-format '("%e" mode-line-front-space
                                  mode-line-buffer-identification))
    :config
    (advice-add 'magit-status-here :after
                (defun magit-recenter (&rest _) (recenter))))
#+end_src

** Ediff - Diff
#+begin_src emacs-lisp
  (use-package ediff
    :custom
    (ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

** Dired - Directory browser
#+begin_src emacs-lisp
  (use-package dired
    :preface
    (defun dired-here ()
      "Open `dired' here."
      (interactive)
      (funcall (if current-prefix-arg 'dired-other-window
                 'dired)
               default-directory))
    :general
    (leader-map "ad" 'dired-here)
    ;; Lets pretend shell-command does not exist
    (dired-mode-map
     :states 'normal
     "!" 'dired-do-async-shell-command
     "&" nil)
    :hook
    (dired-mode . auto-revert-mode)
    (dired-mode . dired-omit-mode)
    (dired-mode . hl-line-mode)
    (dired-mode . (lambda () (recentf-push default-directory)))
    :custom
    ;; If two dired opened use other dired as target
    (dired-dwim-target t)
    (dired-use-ls-dired (not (eq system-type 'darwin)))
    ;; Sort by date as default
    (dired-listing-switches "-alt"))
#+end_src

*** Dired Subtree - Expand directory
#+begin_src emacs-lisp
  (use-package dired-subtree
    :straight t
    :custom
    (dired-subtree-line-prefix "    "))
#+end_src

** Email and Feeds
*** Gnus - Reading mail, feeds and lists
#+begin_src emacs-lisp
  (use-package gnus
    :general
    (leader-map "am" 'gnus)
    (gnus-summary-mode-map
     :states 'normal
     "n" 'gnus-summary-next-page
     "p" 'gnus-summary-prev-page
     "u" 'gnus-summary-put-mark-as-unread
     "!" 'gnus-summary-put-mark-as-ticked)
    (gnus-group-mode-map
     :states 'normal
     "q" 'bury-buffer)
    :hook
    (gnus-group-mode . gnus-topic-mode)
    (gnus-summary-mode . hl-line-mode)
    :custom
    ;; Startup
    (gnus-check-new-newsgroups nil)
    (gnus-check-bogus-newsgroups nil)
    ;; Sensible date format
    (gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M")))
    ;; Looks
    (gnus-group-line-format "%(%M%S%p%P%5y %B %G%)\n")
    (gnus-summary-line-format "%(%U%R %d%z%I%[%-23,23f%] %s%)\n")
    (gnus-treat-strip-trailing-blank-lines 'last)
    (gnus-use-full-window nil)
    ;; Sensible article order
    (gnus-thread-sort-functions '(gnus-thread-sort-by-most-recent-date))
    ;; Show all(ish) groups and articles
    (gnus-permanently-visible-groups ".*")
    (gnus-large-newsgroup 5000)
    ;; Show more MIME-stuff
    (gnus-mime-display-multipart-related-as-mixed t)
    ;; Don't select the first automatically
    (gnus-auto-select-first nil)
    ;; Tree
    (gnus-generate-tree-function 'gnus-generate-horizontal-tree)
    ;; Dribble file
    (gnus-always-read-dribble-file t)
    ;; No useless newsrc file
    (gnus-save-newsrc-file nil)
    ;; Don't ask
    (gnus-interactive-exit nil)
    (gnus-article-browse-delete-temp t)
    ;; Goto next no matter if it's unread or not (RET)
    (gnus-summary-goto-unread 'never)
    ;; Methods
    (gnus-select-method '(nnnil ""))
    (gnus-secondary-select-methods
     '(
       ;; Mail
       (nnmaildir "dpettersson"
                  (directory "~/Mail/dpettersson/"))
       (nnmaildir "svaante"
                  (directory "~/Mail/svaante/"))
       ;; Rss
       (nntp "feedbase.org"
             (nntp-open-connection-function nntp-open-tls-stream)
             (nntp-port-number 563))
       ;; Mailing lists
       (nntp "news.gmane.io")))
  ;; use correct email
    (gnus-posting-styles
     '((".*" ; Matches all groups of messages
        (address "Daniel Pettersson <daniel@dpettersson.net>"))
       ("svaante"
        (address "Daniel Pettersson <svaante@gmail.com>")
        ("X-Message-SMTP-Method" "smtp smtp.gmail.com 587 svaante@gmail.com"))))
    (gnus-parameters
     `(("nnmaildir"
        (gcc-self . t) ;; Let me see my own emails
        ;; (display . 500)
        )
       (,(rx (or "nnrss"
                 "feedbase.org"
                 "news.gwene.org"))
        (gnus-auto-select-first t)
        (gnus-summary-line-format "%U%R%z%d %I%(%s %)\n"))
       ("news.gmane.io"
        (display . 1000)))))
#+end_src

*** Mbsync - Get mail
#+begin_src emacs-lisp
  (defun mbsync ()
    "Run mbsync -a."
    (interactive)
    (with-current-buffer (get-buffer-create " *mbsync*")
      (when (called-interactively-p 'all)
        (display-buffer (current-buffer)))

      (unless (get-buffer-process (current-buffer))
        (erase-buffer)
        (insert (format "Started at %s\n\n" (current-time-string)))
        (make-process :name "mbsync"
                      :command '("mbsync" "-a")
                      :buffer (current-buffer)
                      :noquery t))))

  ;; Cron up `mbsync' running with an period of 5 min
  (run-with-timer 0 (* 60 5) #'mbsync)
#+end_src

*** Display time - New mail notification
#+begin_src emacs-lisp
  (use-package time
    :custom
    (display-time-mail-directory "~/Mail/dpettersson/Inbox/new/")
    (display-time-string-forms
     '((when mail (propertize " Mail" 'face 'mode-line-emphasis))))
    (display-time-mode +1))
#+end_src

*** SMTPmail - Sending mail
#+begin_src emacs-lisp
  (use-package smtpmail
    :custom
    (user-mail-address "daniel@dpettersson.net")
    (user-full-name "Daniel Pettersson")
    ;; use smtpmail
    (send-mail-function 'smtpmail-send-it)
    ;; use gnus?
    (mail-user-agent 'gnus-user-agent)
    ;; gmail
    (smtpmail-smtp-server "smtp.gmail.com")
    (smtpmail-smtp-service 587))
#+end_src

*** Message - Writing mail
#+begin_src emacs-lisp
  (use-package message
    :custom
    ;; why would you keep message buffers around?
    (message-kill-buffer-on-exit t))
#+end_src

** IPython - Calculator
#+begin_src emacs-lisp
  (use-package ipython
    :general
    (leader-map "ac" #'run-ipython)
    (inferior-python-mode-map
     :states 'normal
     "q" 'bury-buffer)
    :preface
    (defun run-ipython ()
      "Run an inferior iPython process."
      (interactive)
      (require 'python)
      (let* ((python-shell-buffer-name "IPython")
             (python-shell-interpreter "ipython")
             (python-shell-interpreter-args "-i --simple-prompt")
             (process (run-python nil nil t)))
        ;; There should not be anything interesting in this IPython process
        (set-process-query-on-exit-flag process nil)
        ;; Maybe this should be part of the `display-buffer-alist'
        ;; `body-function' for TERM/REPL like things.
        (with-current-buffer (process-buffer process)
          (goto-char (point-max))
          (evil-insert-state)))))
#+end_src

** Proced - Task manager
#+begin_src emacs-lisp
  (use-package proced
    :general
    (leader-map "ap" 'proced))
#+end_src

** define-word - Thesaurus
#+begin_src emacs-lisp
  (use-package define-word
    :straight t
    :general
    (leader-map "at" 'define-word-at-point)
    :hook
    (text-mode
     . (lambda ()
           (setq-local evil-lookup-func
                       #'define-word-at-point))))
#+end_src

* Misc commands
#+begin_src emacs-lisp
  ;; source: http://steve.yegge.googlepages.com/my-dot-emacs-file
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive (list (read-string "New name: " (buffer-name (current-buffer)))))
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (progn
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil))))))

  (defun scratch-from-mode (mode)
    "Create scratch buffer for major MODE."
    (interactive
     (list
      (intern (completing-read "Mode: " (mapcar 'cdr auto-mode-alist)
                               nil t))))
    (let ((buffer
           (get-buffer-create (format "*scratch: %s*"
                                      (symbol-name mode)))))
      (with-current-buffer buffer
        (funcall-interactively mode)
        (setq-local buffer-offer-save nil))
      (pop-to-buffer-same-window buffer)))
#+end_src

