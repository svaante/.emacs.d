#+TITLE: Emacs package configuration file
#+PROPERTY: header-args    :results silent

* Basic
#+BEGIN_SRC emacs-lisp
  ;; this is what the man told me to for native compilation
  (setq comp-speed 2)
  (setq package-native-compile t)
  ;; HACK https://github.com/hlissner/doom-emacs/issues/4400
  (setq native-comp-deferred-compilation-deny-list nil)
  ;; remove native comp errors
  (setq native-comp-async-report-warnings-errors nil)

  ;; remove gui elements
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)

  ;; set fringe style to minimal
  ;;(set-fringe-style 0)

  ;; remove visual bell
  (setq visible-bell       nil
        ring-bell-function #'ignore)

  ;; set default dir to home
  (setq default-directory "~/")

  ;; follow symlinks
  (setq vc-follow-symlinks t)

  ;; spaces not tabs
  (setq-default indent-tabs-mode nil)

  ;; no backup files
  (setq make-backup-files nil)
  (global-auto-revert-mode t)

  ;; y/n will do
  (defalias 'yes-or-no-p 'y-or-n-p)
  (setq use-short-answers t)

  ;; stop the insessent blinking
  (blink-cursor-mode 0)

  ;; Backup trails is worse then chem-trails, losing patches is 99% of the time my fault
  (setq auto-save-default nil)

  ;; perf
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 1024 1024))

  ;; Remove that pesky help window
  (setq inhibit-startup-screen t)

  ;; Resize frames based on pixels
  (setq frame-resize-pixelwise t)
 #+END_SRC

* Platform
** Mac
#+BEGIN_SRC  emacs-lisp
  (when (eq system-type 'darwin)
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    (setq mac-option-key-is-meta t)
    (setq mac-right-option-modifier nil))
#+END_SRC

** Linux
#+begin_src emacs-lisp
  (when (eq system-type 'gnu/linux)
    (global-set-key (kbd "C-+") 'text-scale-increase)
    (global-set-key (kbd "C--") 'text-scale-decrease))
#+end_src

* Package
#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (setq package-enable-at-startup nil)

  (straight-use-package 'use-package)
  (straight-use-package 'el-patch)
#+end_src

* Key mappings
** Global mappings
#+begin_src emacs-lisp
  (use-package emacs
    :after evil
    :config
    (defun +emacs/split-follow-window-vertically ()
      "Split and follow window vertically."
      (interactive)
      (split-window-vertically) (other-window 1))

    (defun +emacs/split-follow-window-horizontally ()
      "Split and follow window horizontally."
      (interactive)
      (split-window-horizontally) (other-window 1))

    ;; create my own global intercept map for global evil keybindings
    (defvar global-intercept-mode-map (make-sparse-keymap)
      "High precedence keymap.")

    (define-minor-mode global-intercept-mode
      "Global minor mode for higher precedence keybindings."
      :global t)

    (global-intercept-mode)

    (dolist (state '(normal visual insert))
      (evil-make-intercept-map
       ;; NOTE: This requires an evil version from 2018-03-20 or later
       (evil-get-auxiliary-keymap global-intercept-mode-map state t t)
       state))

    ;; HACK: To seperate C-i with <tab> in terminal <Tab> is more important then C-i
    (when (display-graphic-p)
      (define-key input-decode-map (kbd "C-i") (kbd "H-i")))

    (evil-define-key '(normal insert) global-intercept-mode-map
      "\C-j" 'evil-window-down
      "\C-k" 'evil-window-up
      "\C-h" 'evil-window-left
      "\C-l" 'evil-window-right
      (kbd "H-i") 'evil-jump-forward
      "\C-o" 'evil-jump-backward
      "\C-ws" '+emacs/split-follow-window-vertically
      "\C-wv" '+emacs/split-follow-window-horizontally))
#+end_src

** Leader mappings
#+BEGIN_SRC emacs-lisp
  (use-package general
    :straight t
    :config
    (general-create-definer leader-key
      :prefix "SPC"
      :states '(normal emacs motion visual)
      :keymaps 'override))
#+END_SRC

** Evil
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :straight t
    :config
    (setq undo-tree-auto-save-history nil)
    (global-undo-tree-mode 1))

  (use-package evil
    :straight t
    :init
    (setq evil-mode-line-format nil)
    (setq evil-want-C-i-jump nil)
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-Y-yank-to-eol t)
    (setq evil-want-C-u-scroll t)
    (setq evil-search-module 'evil-search)
    (setq evil-want-minibuffer t)
    (setq evil-undo-system 'undo-tree)
    (setq evil-jumps-cross-buffers t)
    (setq evil--jumps-buffer-targets  "\\*\\(.+\\)\\*")
    (setq evil-insert-state-message nil)
    (setq evil-normal-state-message nil)
    (setq-default evil-symbol-word-search t)
    (setq-default evil-shift-width 2)
    :config
    ;; use symbols instead of words when using the vim subject "word"
    (defalias #'forward-evil-word #'forward-evil-symbol)

    ;; run the macro in the q register
    (evil-define-key 'normal 'global "Q" "@q")

    ;; Keep eldoc message on insert
    (eldoc-add-command 'evil-change)
    (eldoc-add-command 'evil-insert)
    (eldoc-add-command 'evil-escape)

    ;; my common misspellings
    (evil-ex-define-cmd "E[dit]" 'evil-edit)
    (evil-ex-define-cmd "W[rite]" 'evil-write)
    (evil-ex-define-cmd "Wq" 'evil-save-and-close)
    (evil-ex-define-cmd "WQ" 'evil-save-and-close)
    (evil-ex-define-cmd "Wq" 'evil-save-and-close)
    (evil-ex-define-cmd "Qa[ll]" "quitall")
    (evil-ex-define-cmd "qA[ll]" "quitall")
    (evil-ex-define-cmd "QA[ll]" "quitall")
    (evil-mode 1))

  (use-package evil-surround
    :straight t
    :config
    (global-evil-surround-mode 1))

  (use-package evil-escape
    :straight t
    :init
    (setq evil-escape-delay 0.2)
    (setq evil-escape-unordered-key-sequence t)
    (setq-default evil-escape-key-sequence "jk")
    :config
    (evil-escape-mode))

  (use-package evil-collection
    :after evil
    :straight t
    :config
    ;; magit uses 'C-i' as tab like GUI emacs doesn't exist
    (evil-define-key 'normal magit-mode-map (kbd "<tab>") #'magit-section-cycle)

    (thread-last evil-collection-mode-list
                 (remove 'eshell)
                 (remove 'corfu)
                 (setq evil-collection-mode-list))
    (evil-collection-init)
    (leader-key "js" 'evil-collection-consult-jump-list))

  (use-package evil-org
    :defer t
    :straight t
    :after org
    :hook ((org-mode . evil-org-mode)
           (evil-org-mode . (lambda ()
                              (evil-org-set-key-theme '(textobjects
                                                        insert
                                                        return
                                                        return
                                                        additional
                                                        shift
                                                        todo))))))
#+END_SRC

** Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :straight t)
#+end_src

** Repeat
#+begin_src emacs-lisp
  (use-package repeat
    :straight (:type built-in)
    :config
    (repeat-mode))
#+end_src

* Window
** Display buffer
#+begin_src emacs-lisp
  ;; (setq fit-window-to-buffer-horizontally t)
  ;; (setq fit-frame-to-buffer t)

  ;; Prefer vertical splits over horizontal splits
  ;; (setq split-width-threshold 190)
  ;; (setq split-height-threshold 120)

  (setq split-height-threshold nil)
  (setq split-width-threshold (* 2 90))

  (setq display-buffer-base-action
        '((display-buffer-reuse-window
           display-buffer-in-previous-window)))

  (setq window-sides-vertical t)
  (setq window-combination-resize t)
  (setq switch-to-buffer-in-dedicated-window 'pop)
  (setq even-window-sizes 'height-only)

  (setq display-buffer-alist
        `(;; Org capture select
          ("\\*Org \\(Select\\|Note\\)\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((mode-line-format . none))))
          ;; Status buffers
          ((or . ((derived-mode . flymake-diagnostics-buffer-mode)
                  (derived-mode . flymake-project-diagnostics-mode)
                  (derived-mode . messages-buffer-mode)
                  (derived-mode . backtrace-mode)
                  "\\(\\*Capture\\*\\|CAPTURE-.*\\)"))
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . 0.3)
           (dedicated . t)
           (preserve-size . (t . t))
           ;; Make window unsupportable
           (body-functions . window-make-atom))
          ;; Result type buffers
          ((or . ((derived-mode . occur-mode)
                  (derived-mode . ibuffer-mode)
                  (derived-mode . grep-mode)
                  (derived-mode . xref--xref-buffer-mode)
                  (derived-mode . embark-collect-mode)
                  "\\*Embark Export: .*\\*"))
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (dedicated . t)
           (window-height . 0.4))
          ;; Things that pop from the right
          ((or . ((derived-mode . help-mode)
                  (derived-mode . Man-mode)
                  (derived-mode . devdocs-mode)
                  (derived-mode . shortdoc-mode)
                  "\\*eldoc.*\\*"))
           (display-buffer-in-direction)
           (direction . rightmost)
           (window-width . 75)
           (dedicated . t)
           (body-function . (lambda (window) (select-window window))))
          ;; Side window stuff
          ((or . (,(regexp-quote shell-command-buffer-name-async)
                  (major-mode . compilation-mode)))
           (display-buffer-in-side-window)
           (side . right)
           (dedicated . t)
           (window-width . 75))))
#+end_src

** Ace window
#+begin_src emacs-lisp
  (use-package ace-window
    :straight t
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (leader-key "jw" 'ace-window))
#+end_src

** Mappings
#+begin_src emacs-lisp
  (leader-key
    "w" '(:ignore t :which-key "Manage windows")
    "wt" 'toggle-frame-maximized
    "wm" 'toggle-frame-fullscreen)
#+end_src

* Looks
** Fonts
#+begin_src emacs-lisp
  ;; Mac font
  (when (eq system-type 'darwin)
    (set-face-attribute 'default nil :font "Monaco 12")
    ;; (set-face-attribute 'default nil :font "Terminus (TTF) 14")
    (set-fontset-font t
                      '(#x1f300 . #x1f5ff)
                      (font-spec :family "Apple Color Emoji" :size 11)))

  ;; Linux font
  (when (eq system-type 'gnu/linux)
    (set-face-attribute 'default nil :font "DejaVu Sans Mono 9"))
#+end_src

** Themes
#+BEGIN_SRC emacs-lisp
  (use-package ef-themes
    :straight (ef-themes :type git :host github :repo "protesilaos/ef-themes")
    :config
    (setq ef-themes-common-palette-overrides
          '((bg-mode-line bg-dim)
            (bg-alt bg-main))))

  (use-package standard-themes
    :straight t)

  (use-package modus-themes
    :straight t
    :config

    (setq modus-themes-completions
          (quote ((matches . (extrabold underline))
                  (selection . (semibold)))))

    (setq modus-themes-headings
          (quote ((1 . (variable-pitch 1.5))
                  (2 . (1.3))
                  (agenda-date . (1.3))
                  (agenda-structure . (variable-pitch light 1.8))
                  (t . (1.1)))))

    (setq modus-themes-org-blocks 'gray-background)

    (setq modus-themes-common-palette-overrides
          '((fringe bg-main))))

  (use-package grandshell-theme :straight t)

  (use-package inkpot-theme :straight t)

  (use-package zenburn-theme :straight t)

  (use-package doom-themes :straight t)

  (use-package wildcharm-theme :straight t)
#+END_SRC

** Mode-line
#+begin_src emacs-lisp
  (defun mode-line-file-path ()
    (when-let ((file-name (buffer-file-name)))
      (propertize
       (abbreviate-file-name
        (or (when-let* ((prj (project-project-root))
                        (prj-parent (file-name-directory
                                     (directory-file-name
                                      (expand-file-name prj))))
                        (rel-path
                         (file-relative-name
                          (file-name-directory buffer-file-truename)
                          prj-parent)))
              (if (length< rel-path 60)
                  rel-path
                (let ((split-rel-path (file-name-split rel-path)))
                  (file-name-as-directory
                   (apply 'file-name-concat (car split-rel-path)
                          (mapcar (lambda (p)
                                    (if (string-empty-p p)
                                        p
                                      (substring p 0 1)))
                                  (cdr split-rel-path)))))))
            default-directory))
       'mouse-face 'highlight
       'help-echo (file-name-directory file-name))))

  (setq mode-line-position-column-line-format '(" %l:%c"))

  (defface evil-state-tag-face
    '((t (:inherit (match font-lock-constant-face mode-line))))
    "Face for mode line evil mode indication.")

  (setq-default mode-line-format
                '(
                  ""
                  mode-line-front-space
                  mode-line-mule-info
                  mode-line-client
                  mode-line-modified
                  mode-line-remote
                  mode-line-frame-identification
                  " "
                  (:eval (mode-line-file-path))
                  mode-line-buffer-identification
                  "  "
                  mode-line-position
                  " "
                  (:propertize mode-name
                               face bold)
                  "  "
                  (vc-mode vc-mode)
                  " "
                  (:eval (when (window-dedicated-p)
                           (propertize " Dedicated"
                                       'face 'font-lock-warning-face)))
                  (:eval (when (buffer-narrowed-p)
                           (propertize " Narrow"
                                       'face 'font-lock-warning-face)))
                  (:eval (when (region-active-p)
                           (format " Lines %d" (1+ (count-lines (region-beginning)
                                                                (region-end))))))
                  (defining-kbd-macro mode-line-defining-kbd-macro)
                  " "
                  mode-line-process
                  mode-line-misc-info
                  mode-line-format-right-align))

  (column-number-mode 1)
#+end_src

** Whitespace
*** Show whitespace
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :straight (:type built-in)
    :hook (prog-mode . whitespace-mode)
    :init
    (setq show-trailing-whitespace t)
    (setq whitespace-line-column 80)
    (setq whitespace-style '(face trailing lines-char)))
#+END_SRC

** Dashboard
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :straight t
    :config
    (setq dashboard-items '((recents  . 10)
                            (bookmarks . 10)))
    (dashboard-setup-startup-hook))
#+END_SRC

** Visual lines
#+begin_src emacs-lisp
  (use-package simple
    (global-visual-line-mode t))
#+end_src

* Buffer navigation
** Narrow
#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first.  Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          ((not (thing-at-point 'defun)) (narrow-to-page))
          (t (narrow-to-defun))))

  (leader-key "z" 'narrow-or-widen-dwim)
#+END_SRC

** Avy
#+begin_src emacs-lisp
  (use-package avy
    :straight t
    :config
    (advice-add 'avy-read :before (lambda (&rest _) (avy-show-dispatch-help)))
    (advice-add 'avy-read-de-bruijn :before (lambda (&rest _) (avy-show-dispatch-help)))

    (setq avy-timeout-seconds 0.3)
    (setq avy-style 'de-bruijn)
    (setq avy-line-insert-style 'below)

    (defun avy-goto-line-keep-column (&optional arg)
      "Jump to a line at the current column."
      (interactive "p")
      (let ((window (selected-window))
            (column (current-column)))
        (avy-goto-line arg)
        (when (equal window (selected-window))
           (move-to-column column))))

    (evil-define-avy-motion avy-goto-line-keep-column line)

    (defun avy-action-visual (pt)
      (let (beg end)
        (goto-char pt)
        (setq beg (point))
        (avy-forward-item)
        (backward-char)
        (setq end (point))
        (evil-visual-select beg end)))

    (defun avy-action-paste-line (pt)
      (avy-action-yank-line pt))

    (defun avy-action-paste (pt)
      (avy-action-yank pt))

    (setq avy-dispatch-alist
          '((?x . avy-action-kill-move)
            (?X . avy-action-kill-stay)
            (?v . avy-action-visual)
            (?w . avy-action-copy)
            (?p . avy-action-paste)
            (?P . avy-action-paste-line)
            (?z . avy-action-ispell)))

    (leader-key
      "jj" 'evil-avy-goto-char-timer
      "jl" 'evil-avy-goto-line-keep-column))
#+end_src

* Org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight (:type built-in)
    :hook ((org-mode . org-indent-mode)
           (org-mode . visual-line-mode))
    :config
    (defun +org-confirm-babel-evaluate (lang body)
      (not (member lang '("sh" "emacs-lisp" "python"))))
    ;; Open Link in same window
    (add-to-list 'org-link-frame-setup '(file . find-file))

    (setq org-return-follows-link t)
    (setq org-confirm-babel-evaluate '+org-confirm-babel-evaluate)
    (setq org-src-window-setup 'current-window)
    (setq org-startup-with-inline-images t)

    ;; Enable babel languages
    (org-babel-do-load-languages 'org-babel-load-languages
                                 '((shell . t)
                                   (python . t)))

    (evil-define-key 'normal org-mode-map
      (kbd "<RET>") 'org-return)

    (leader-key "os" 'org-store-link))

  (use-package org-agenda
    :config
    ;; Dont touch my windows
    (defun org-agenda-well-behaved (old-org-agenda &rest args)
      "Does not close the other opend window before opening the capture buffer"
      (interactive)
      (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
        (apply old-org-agenda args)))
    (advice-add 'org-agenda :around 'org-agenda-well-behaved)

    (setq org-agenda-breadcrumbs-separator " ")
    (setq org-agenda-prefix-format '((agenda .  "  %?-40 b")
                                     (todo .    "  %?-40 b")
                                     (tags .    "  %?-40 b")
                                     (search .  "  %?-40 b")))

    (setq org-todo-keywords
          '((sequence "TODO" "DONE")))

    ;; Replace the original agenda
    (setq org-agenda-custom-commands
          '(("A" "Agenda"
             ((agenda)
              (tags "+LEVEL=1-SCHEDULED={.+}-DEADLINE={.+}/TODO"
                    ((org-agenda-overriding-header "Todos:")))
              (tags "-hide+LEVEL>1-SCHEDULED={.+}/TODO"
                    ((org-agenda-overriding-header "Projects:")))))))

    (defun org-agenda-custom ()
      (interactive)
      (org-agenda nil "A"))

    (leader-key
      "oa" 'org-agenda-custom
      "oA" 'org-agenda
      "ot" 'org-todo-list
      "ow" 'org-agenda-list)

    (setq org-agenda-files '("~/org/notes.org"
                             "~/org/pad.org"
                             "~/org/todo.org"))

    ;; Create files if they do not exist
    (seq-do (lambda (file)
              (unless (file-exists-p file)
                (message "File %s created at startup" file)
                (make-empty-file file)))
            org-agenda-files)

    ;; been trying to use evil-org's evil-agenda only result was pain
    (evil-set-initial-state 'org-agenda-mode 'normal)
    (evil-define-key 'normal org-agenda-mode-map
      (kbd "<RET>") 'org-agenda-goto
      "q" 'org-agenda-quit
      "r" 'org-agenda-redo
      "K" 'org-agenda-priority-up
      "J" 'org-agenda-priority-down
      "n" 'org-agenda-add-note
      "t" 'org-agenda-todo
      "#" 'org-agenda-set-tags
      "j" 'org-agenda-next-line
      "k" 'org-agenda-previous-line
      "f" 'org-agenda-later
      "b" 'org-agenda-earlier
      "e" 'org-agenda-set-effort
      "." 'org-agenda-goto-today
      "H" 'org-agenda-do-date-earlier
      "L" 'org-agenda-do-date-later))

  (use-package org-capture
    :config
    ;; Dont touch my windows
    (defun org-capture-well-behaved (old-org-capture &rest args)
      "Does not close the other opened window before opening the capture buffer"
      (interactive)
      (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
        (apply old-org-capture args)))
    (advice-add 'org-capture :around 'org-capture-well-behaved)

    (add-hook 'org-capture-mode-hook (lambda (&rest _) (evil-insert 1)))

    (setq org-agenda-follow-indirect t)
    (setq org-refile-use-outline-path 'file)
    (setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
    (setq org-outline-path-complete-in-steps nil)

    (setq org-capture-templates '(("p" "Pad" plain
                                   (file+olp+datetree "~/org/pad.org")
                                   "\n%?\n"
                                   :unnarrowed t)
                                  ("n" "Note" entry
                                   (file "~/org/notes.org")
                                   "* %?\n")
                                  ("t" "Todo" entry
                                   (file "~/org/todo.org")
                                   "* TODO %?\n")
                                  ("l" "Link" entry
                                   (file "~/org/todo.org")
                                   "* TODO %? %a\n")))
    (leader-key "oc" 'org-capture))

  (use-package org-modern
    :straight (org-modern :type git :host github :repo "minad/org-modern")
    :hook ((org-mode . org-modern-mode))
    :config
    ;; Some type of fix when using org-indent-mode
    (setq org-modern-block-fringe nil))
#+END_SRC

** Notes
#+begin_src emacs-lisp
  (use-package org-mono
    :after embark
    :straight (org-mono :type git :host github :repo "svaante/org-mono")
    :config
    (setq org-mono-files '("~/org/notes.org"
                           "~/org/pad.org"
                           "~/org/thoughts.org"
                           "~/.emacs.d/config.org"))

    (setq org-mono-advice-org-refile t)

    (leader-key "oo" 'org-mono-goto)

    (defvar-keymap embark-org-mono-actions-map
      :doc "Keymap for actions for org-mono."
      :parent embark-general-map
      "o" #'org-mono-goto-other-window
      "t" #'org-mono-todo
      "r" #'org-mono-rename
      "w" #'org-mono-refile-from
      "a" #'org-mono-archive
      "k" #'org-mono-delete-headline
      "c" #'org-mono-goto-headline-child
      "d" #'org-mono-time-stamp
      "b" #'org-mono-goto-backlinks)

    (add-to-list 'embark-keymap-alist '(org-mono . embark-org-mono-actions-map))

    (global-org-mono-mode))

  (use-package org-mono-consult
    :after consult
    :straight (org-mono-consult :type git :host github :repo "svaante/org-mono")
    :config
    (setq org-mono-completing-read-fn 'org-mono-consult-completing-read))
#+end_src

* Completion
** Basics
#+begin_src emacs-lisp
  (delete ".bin" completion-ignored-extensions)
  (setq completion-ignore-case t)
#+end_src

** Package company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :disabled
    :straight t
    :config
    (setq company-backends '(company-files company-capf))
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 2)
    (setq company-tooltip-align-annotations t)
    (setq company-global-modes '(not eshell-mode))
    (setq company-format-margin-function #'company-text-icons-margin)
    (setq company-selection-wrap-around t)
    (setq company-dabbrev-ignore-case nil)
    (setq company-dabbrev-downcase nil)

    ;; Something creept in during update where c-n/c-p would sometimes
    ;; trigger evil-complete-next/previous
    (defun evil-complete-next-company (func arg)
      (if (company--active-p)
          (call-interactively 'company-select-next)
        (funcall func arg)))

    (defun evil-complete-previous-company (func arg)
      (if (company--active-p)
          (call-interactively 'company-select-previous)
        (funcall func arg)))

    (advice-add 'evil-complete-next
                :around
                #'evil-complete-next-company)
    (advice-add 'evil-complete-previous
                :around
                #'evil-complete-previous-company)

    (define-key company-active-map (kbd "RET") nil)
    (define-key company-active-map (kbd "<return>") nil)
    (define-key company-active-map (kbd "TAB") 'company-complete)
    (define-key company-active-map (kbd "<tab>") 'company-complete)

    (global-company-mode 1))

  (use-package company-posframe
    :disabled
    :straight t
    :config
    (setq company-posframe-show-metadata nil)
    (setq company-posframe-show-indicator nil)
    (setq company-posframe-quickhelp-delay nil)
    (company-posframe-mode 1))
#+END_SRC

** Corfu
#+begin_src emacs-lisp
  (use-package corfu
    :straight (corfu :files (:defaults "extensions/*")
                     :includes (corfu-popupinfo corfu-history))
    :hook (evil-insert-state-exit . corfu-quit)
    :config
    (setq corfu-cycle t)
    (setq corfu-auto t)
    (setq corfu-preselect 'first)
    (setq corfu-quit-no-match t)
    (setq corfu-auto-prefix 2)
    (setq corfu-on-exact-match 'quit)

    ;; Orderless completion
    (setq corfu-separator ?s)
    (setq corfu-quit-at-boundary nil)

    ;; In eshell use tab to open corfu
    (setq corfu-excluded-modes '(eshell-mode))
    (add-hook 'eshell-mode-hook
              (lambda ()
                (setq-local corfu-auto nil)
                (corfu-mode)))

    ;; C-n C-p
    (evil-make-overriding-map corfu-map)
    (advice-add 'corfu--setup :after 'evil-normalize-keymaps)
    (advice-add 'corfu--teardown :after 'evil-normalize-keymaps)
    (evil-define-key 'insert corfu-map
      (kbd "C-n") 'corfu-next
      (kbd "C-p") 'corfu-previous)

    (define-key corfu-map (kbd "RET") nil)
    (global-corfu-mode)

    (setq corfu-popupinfo-delay '(0.5 . 0.0))
    (corfu-popupinfo-mode)

    (corfu-history-mode))

  (use-package corfu-terminal
    :straight t
    :config
    (unless (display-graphic-p)
      (corfu-terminal-mode +1)))

  (use-package cape
    :straight t
    :hook ((lsp-mode . coruf-lsp-mode-completions)
           (eglot-managed-mode . coruf-eglot-completions))
    :init
    ;; Default completion at point additions
    (add-to-list 'completion-at-point-functions #'cape-history)

    (add-to-list 'completion-at-point-functions #'cape-file)

    (defun coruf-lsp-mode-completions ()
      (setq-local completion-at-point-functions
                  (cons #'tempel-complete
                        (list (cape-super-capf
                               #'lsp-completion-at-point)
                              #'cape-file))))

    (defun coruf-eglot-completions ()
      (setq-local completion-at-point-functions
                  (cons #'tempel-complete
                        (list #'cape-file
                              #'eglot-completion-at-point)))))

#+END_SRC

** Vertico, consult, embark
#+begin_src emacs-lisp
  (use-package vertico
    :straight (vertico
               :type git
               :host github
               :repo "minad/vertico"
               :files (:defaults "extensions/*")
               :includes (vertico-repeat vertico-directory))
    :hook ((rfn-eshadow-update-overlay . vertico-directory-tidy)
           (minibuffer-setup . vertico-repeat-save))
    :init
    (vertico-mode)

    (setq vertico-cycle t)
    (setq enable-recursive-minibuffers nil)

    ;; Use evil in the minibuffer
    (evil-define-key '(insert normal) minibuffer-local-map
      (kbd "RET") 'vertico-exit
      (kbd "C-n") 'vertico-next
      (kbd "C-p") 'vertico-previous)

    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))

    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    (leader-key "r" 'vertico-repeat-select)

    (evil-define-key '(insert normal) vertico-map
      (kbd "DEL") 'vertico-directory-delete-char
      (kbd "M-DEL") 'vertico-directory-delete-word))

  (defun use-orderless-in-minibuffer ()
    (setq-local completion-styles '(orderless basic)))

  (use-package orderless
    :straight t
    :hook (minibuffer-setup . use-orderless-in-minibuffer)
    :init
    ;; Escape spaces with ?\
    (setq orderless-component-separator 'orderless-escapable-split-on-space)

    (defun without-if-bang (pattern _index _total)
      (cond
       ((equal "!" pattern)
        '(orderless-literal . ""))
       ((string-prefix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 1)))))

    (setq orderless-style-dispatchers
          '(without-if-bang))

    (setq completion-styles '(basic orderless))

    (setq completion-category-defaults nil
          completion-category-overrides
          '((file (styles basic partial-completion))
            (lsp-capf (styles basic)))))

  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :straight t
    :init
    (savehist-mode))

  ;; Enable richer annotations using the Marginalia package
  (use-package marginalia
    :straight t
    :config
    (marginalia-mode))

  (defun consult-line-evil-history (&rest _)
    "Add latest `consult-line' search pattern to the evil search history ring.
  This only works with orderless and for the first component of the search."
    (when (and (bound-and-true-p evil-mode)
               (eq evil-search-module 'evil-search))
      (let ((pattern (car (orderless-pattern-compiler (car consult--line-history)))))
        (add-to-history 'evil-ex-search-history pattern)
        (setq evil-ex-search-pattern (list pattern t t))
        (setq evil-ex-search-direction 'forward)
        (when evil-ex-search-persistent-highlight
          (evil-ex-search-activate-highlight evil-ex-search-pattern)))))

  (advice-add #'consult-line :after #'consult-line-evil-history)

  (use-package consult
    :straight (consult :type git :host github :repo "minad/consult")
    :config
    (evil-define-key '(insert normal) minibuffer-local-map
      (kbd "C-r") 'consult-history)

    (setq xref-show-xrefs-function 'consult-xref)

    (defun +consult-kill-line-insert-history ()
      (interactive)
      (goto-char (point-max))
      (ignore-errors (call-interactively 'move-beginning-of-line) t)
      (ignore-errors (call-interactively 'kill-line) t)
      (call-interactively 'consult-history))

    (evil-define-key 'insert comint-mode-map
      (kbd "C-r") '+consult-kill-line-insert-history)
    (evil-define-key 'normal comint-mode-map
      (kbd "C-r") '+consult-kill-line-insert-history)

    (defun +consult-ripgrep-fallback-advice (old-fn &rest args)
      (interactive)
      (if (executable-find "rg")
          (funcall old-fn)
        (consult-grep)))

    (consult-customize
     consult-history :initial nil)

    (advice-add 'consult-ripgrep :around #'+consult-ripgrep-fallback-advice)

    (leader-key
      "."  'find-file-at-point
      "pg" 'consult-ripgrep
      "pl" 'consult-locate
      "b"  'consult-buffer
      "i"  'consult-imenu
      "hh" 'describe-function
      "hv" 'describe-variable
      "m"  'consult-bookmark
      "jm" 'consult-mark
      "jc" 'consult-compile-error
      "je" 'consult-flymake
      "y"  'consult-yank-pop
      ":"  'execute-extended-command
      "s"  'consult-line)
    :config
    ;; Do not preview buffers in consult-buffer
    (consult-customize consult-buffer :preview-key '())

    ;; Add eshell as a buffer source
    (defvar eshell-buffer-source
      `(:name     "Eshell Buffer"
                  :narrow   (?e . "Eshell")
                  :hidden   t
                  :category buffer
                  :face     consult-buffer
                  :history  buffer-name-history
                  :state    ,#'consult--buffer-state
                  :items
                  ,(lambda ()
                     (consult--buffer-query :mode 'eshell-mode
                                            :as #'buffer-name)))
      "Eshell buffer candidate source for `consult-buffer'.")
    (add-to-list 'consult-buffer-sources 'eshell-buffer-source 'append)

    ;; Use semicolon as spliter
    (setq consult-async-split-style 'semicolon)

    ;; Add repl buffer source for easier repl creation
    (setq consult-buffer-repls '(("*ielm*"   . ielm)
                                 ("*Python*" . run-python)
                                 ("*nodejs*" . nodejs-repl)
                                 ("*eshell*" . eshell)
                                 ("*SQL: MySQL*" . sql-mysql)))

    (defun open-repl-other-window (key)
      (interactive
       (list (completing-read "Switch to REPLish: "
                              (->> consult-buffer-repls
                                   (mapcar 'car))
                              nil
                              t)))
      (call-interactively (alist-get key consult-buffer-repls nil nil 'equal)))

    (defvar repl-buffer-source
      `(:name     "REPLish buffers"
                  :narrow   (?r . "REPL")
                  :hidden   nil
                  :category consult-repl
                  :face     consult-buffer
                  :state    ,#'consult--buffer-state
                  :history  buffer-name-history
                  :action   ,(lambda (key)
                               (funcall (alist-get key consult-buffer-repls)))
                  :items    ,(lambda ()
                               (->> consult-buffer-repls
                                    (mapcar 'car)))
                  "Repl buffer candidate source for `consult-buffer'."))

    (add-to-list 'consult-buffer-sources 'repl-buffer-source 'append)

    ;; Use consult as the completion-in-region in minibuffer
    (add-hook 'minibuffer-mode-hook
              (lambda (&rest _)
                (setq-local completion-in-region-function
                            (lambda (&rest args)
                              (apply (if vertico-mode
                                         #'consult-completion-in-region
                                       #'completion--in-region)
                                     args))))))

  (use-package which-key
    :straight t
    :init
    (which-key-mode))

  (defun +find-file-at (file)
    "Find file at `default-directory' FILE."
    (interactive "Directory: ")
    (let* ((default-directory (file-name-directory
                               (expand-file-name
                                (substitute-in-file-name file)))))
      (call-interactively 'find-file)))

  (defun +magit-there (file)
    "Run magit in directory of FILE."
    (interactive "Directory: ")
    (let ((default-directory (file-name-directory
                              (expand-file-name
                               (substitute-in-file-name file)))))
      (windmove-display-same-window)
      (magit-status default-directory)))

  (use-package embark-consult
    :straight (embark-consult :type git :host github :repo "oantolin/embark"))

  (use-package embark
    :straight (embark :type git :host github :repo "oantolin/embark")
    :after embark-consult
    :config

    (defun embark-act-noquit ()
      "Run action but don't quit the minibuffer afterwards."
      (interactive)
      (let ((embark-quit-after-action nil))
        (embark-act)))

    (evil-define-key '(insert normal) minibuffer-local-map
      (kbd "C-SPC") 'embark-act
      (kbd "C-@") 'embark-act ;; In terminal C-@ -> {C-SPC,C-S-SPC}
      (kbd "C-S-SPC") 'embark-act-noquit
      (kbd "C-<return>") 'embark-export)

    ;; Show Embark actions via which-key
    (setq embark-action-indicator
          (lambda (map)
            (which-key--show-keymap "Embark" map nil nil 'no-paging)
            #'which-key--hide-popup-ignore-command)
          embark-become-indicator embark-action-indicator)

    (define-key embark-file-map "." '+find-file-at)
    (define-key embark-file-map "g" '+magit-there)
    (define-key embark-file-map "G" 'consult-ripgrep)
    (define-key embark-file-map "e" '+eshell-from-path)
    (define-key embark-file-map "E" '+eshell-from-path-other-window)

    (defvar-keymap embark-repls-actions-map
      :doc "Keymap for actions for repls"
      :parent embark-general-map
      "o" #'open-repl-other-window)

    (add-to-list 'embark-keymap-alist '(consult-repl . embark-repls-actions-map)))
#+end_src

** Minibuffer
#+BEGIN_SRC emacs-lisp
  (setq minibuffer-insert-commands '(consult-line
                                     consult-ripgrep
                                     consult-lsp-symbols
                                     consult-eglot-symbols
                                     async-shell-command
                                     project-async-shell-command))

  (defun minibuffer-insert-selection ()
    (when-let* ((_ (member this-command minibuffer-insert-commands))
                (minibuffer-buffer (current-buffer))
                (buffers (buffer-list))
                (last-used-buffer (cadr buffers)))
      (with-current-buffer last-used-buffer
        (when (use-region-p)
          (let ((selection (buffer-substring-no-properties (region-beginning) (region-end))))
            (deactivate-mark)
            (with-current-buffer minibuffer-buffer
              (insert selection)))))))

  (add-hook 'minibuffer-setup-hook 'minibuffer-insert-selection)
#+end_src

* Editing
** Linewrap
#+begin_src emacs-lisp
  (use-package simple
    :hook ((prog-mode . auto-fill-mode)
           (prog-mode . (lambda ()
                          (setq-local comment-auto-fill-only-comments t)))
           (text-mode . auto-fill-mode)
           (mail-mode . auto-fill-mode)
           (message-mode . auto-fill-mode)))
#+end_src

** Snippets - Tempel
#+begin_src emacs-lisp
  (use-package tempel
    :straight (tempel :type git :host github :repo "minad/tempel")
    :hook (evil-insert-state-exit . tempel-done)
    :config
    (defun tempel-setup-capf ()
      (setq-local completion-at-point-functions
                  (cons #'tempel-complete
                        completion-at-point-functions)))

    (setq tempel-trigger-prefix "!")

    (defun tempel-or-corfu-complete-next ()
      (interactive)
      (if completion-in-region-mode
          (call-interactively 'corfu-complete)
       (call-interactively 'tempel-next)))

    (define-key tempel-map (kbd "TAB") 'tempel-or-corfu-complete-next)
    (define-key tempel-map (kbd "<tab>") 'tempel-or-corfu-complete-next)
    (define-key tempel-map (kbd "<backtab>") 'tempel-previous)
    (define-key tempel-map (kbd "S-TAB") 'tempel-previous)

    (add-hook 'eshell-mode-hook 'tempel-setup-capf)
    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf))

  (use-package tempel-collection :straight t)
#+end_src

* Project management
#+begin_src emacs-lisp
  (defmacro project-with-directory (force &rest body)
    "Try to set `default-dirctory' by using project.el.

    If FORCE is non nil prompt user for project if not already inside of
    project else use `default-directory'"
    (declare (indent 1) (debug t))
    `(let ((default-directory (or (and (project-current ,force)
                                       (project-root (project-current ,force)))
                                  default-directory)))
       ,@body))

  (defun project-project-root (&optional force)
    (when-let ((project (project-current force)))
      (project-root project)))

  (defun project-find-file-at (file)
    "Run project-find-file in directory of FILE."
    (interactive "Directory: ")
    (let* ((default-directory (file-name-directory
                               (expand-file-name
                                (substitute-in-file-name file)))))
      (project-find-file)))

  (defun project-recompile ()
    "Re-compile current project."
    (interactive)
    (project-with-directory t
      (recompile)))

  (use-package project
    :straight t
    :config
    (setq project-vc-extra-root-markers '(".projectile" ".project"))
    (setq project-switch-commands 'project-find-file)
    (setq project-read-file-name-function
          ;; Remove current visited file from list
          (lambda (prompt all-files &optional predicate hist mb-default)
            (when buffer-file-name
              (setq all-files (remove buffer-file-name all-files)))
            (project--read-file-cpd-relative prompt all-files predicate hist mb-default)))

    (defun project-switch-project-advice (project-switch-project dir)
      "Fix embark after switching project."
      (minibuffer-with-setup-hook
          (lambda () (setq default-directory dir))
        (funcall project-switch-project dir)))

    (advice-add 'project-switch-project :around 'project-switch-project-advice)

    (define-key embark-file-map " " 'project-find-file-at)

    (leader-key
      "SPC" 'project-find-file
      "pp" 'project-switch-project
      "p!" 'project-async-shell-command
      "pk" 'project-kill-buffers
      "pc" 'project-compile
      "pC" 'project-recompile))
#+end_src

* Terminal
** Get $PATH from bash/zsh profiles
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :straight t
    :config
    (exec-path-from-shell-initialize))
#+end_src
** Compleation
#+begin_src emacs-lisp
  (use-package bash-completion
    :disabled
    :straight t
    :init
    (autoload 'bash-completion-dynamic-complete
            "bash-completion"
            "BASH completion hook")
    (add-hook 'shell-dynamic-complete-functions
              #'bash-completion-dynamic-complete))
#+end_src

** Eshell
#+begin_src emacs-lisp
  (defun +eshell-name ()
    (let* ((path-part (if (and (bound-and-true-p eshell-project-type-p)
                               (project-project-root))
                          (format "<%s>"
                                  (-> (project-project-root)
                                      file-name-directory
                                      directory-file-name
                                      file-name-nondirectory))
                        (setq-local eshell-project-type-p nil)
                        (abbreviate-file-name default-directory))))
           (format "*eshell %s*" path-part)))

  (defun +eshell-rename ()
    (interactive)
    (when (bound-and-true-p eshell-mode)
      (rename-buffer (generate-new-buffer-name (+eshell-name)
                                               (buffer-name)))))
  (defun +eshell-dwim ()
    (let* ((name (+eshell-name))
           (buffer (cond
                    ;; If called from eshell buffer generate new buffer
                    ((bound-and-true-p eshell-mode) (generate-new-buffer name))
                    ;; If eshell buffer exist grab that
                    ((get-buffer name) (get-buffer name))
                    ;; Otherwise generate new buffer
                    (t (generate-new-buffer name)))))
      (with-current-buffer buffer
        (unless (bound-and-true-p eshell-mode)
          (eshell-mode))
      buffer)))

  (defun +eshell ()
    (interactive)
    (switch-to-buffer (+eshell-dwim))
    (+eshell/goto-end-of-prompt))

  (defun +eshell-project-dwim ()
    (let* ((default-directory (project-project-root t))
           (eshell-project-type-p t)
           (buffer (+eshell-dwim)))
      (with-current-buffer buffer
        (setq-local eshell-project-type-p t)
      buffer)))

  (defun +eshell-other-window ()
    "Open +eshell in other window."
    (interactive)
    (switch-to-buffer-other-window (+eshell-dwim))
    (+eshell/goto-end-of-prompt))

  (defun +eshell-project ()
    "Open +eshell in project."
    (interactive)
    (switch-to-buffer (+eshell-project-dwim))
    (+eshell/goto-end-of-prompt))

  (defun +eshell-project-other-window ()
    "Open +eshell in project in other window."
    (interactive)
    (switch-to-buffer-other-window (+eshell-project-dwim))
    (+eshell/goto-end-of-prompt))

  (defun +eshell-from-path (path)
    "Open +eshell from PATH."
    (interactive "F")
    (let ((default-directory (file-name-directory
                                (expand-file-name
                                 (substitute-in-file-name path)))))
      (switch-to-buffer (+eshell-dwim))
      (+eshell/goto-end-of-prompt)))

  (defun +eshell-from-path-other-window (path)
    "Open +eshell from PATH in other window."
    (interactive "F")
    (let ((default-directory (file-name-directory
                                (expand-file-name
                                 (substitute-in-file-name path)))))
      (switch-to-buffer-other-window (+eshell-dwim))
      (+eshell/goto-end-of-prompt)))

  (defun +eshell/goto-end-of-prompt ()
    "Move cursor to the prompt when switching to insert mode (if point isn't
                                already there)."
    (interactive)
    (goto-char (point-max))
    (evil-append 1))

  (defun +eshell/consult-esh-history-normal ()
    "Move cursor to the end of the buffer before calling counsel-esh-history
                                  and change `state` to insert."
    (interactive)
    (goto-char (point-max))
    (eshell-bol)
    (unwind-protect
        (kill-line)
      (progn
        (evil-append-line 0)
        (consult-history))))

  (defun eshell-after-split (&rest _)
    (when (bound-and-true-p eshell-mode)
      (+eshell-dwim)))

  (defun +eshell-previous-prompt-hack ()
    "With prompt as field eshell-previous-prompt sets cursor at the beggining of the line and not at prompt begin"
    (interactive)
    (call-interactively 'eshell-previous-prompt)
    (when (= (current-column) 0)
      (call-interactively 'eshell-next-prompt)))

  (defun eshell-mode-configuration ()
    (push 'eshell-tramp eshell-modules-list)

    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    (eshell-hist-initialize)

    (evil-define-key 'normal eshell-mode-map
      "I" (lambda () (interactive) (eshell-bol) (evil-insert 1))
      (kbd "S") (lambda () (interactive) (eshell-bol) (kill-line) (evil-append 1))
      (kbd "C-p") '+eshell-previous-prompt-hack
      (kbd "C-n") 'eshell-next-prompt
      (kbd "C-r") '+eshell/consult-esh-history-normal
      (kbd "<return>") '+eshell/goto-end-of-prompt
      "q" (lambda () (interactive) (kill-buffer)))

    (evil-define-key 'insert eshell-mode-map
      (kbd "C-r") '+consult-kill-line-insert-history)


    (evil-define-key 'visual 'local
      (kbd "<return>") (lambda () (interactive) (progn (eshell-send-input t) (evil-normal-state)))))

  (defun +eshell-make-field ()
    "Make text in front of the point a field, useful for prompts."
    (let ((inhibit-read-only t))
      (add-text-properties
       (line-beginning-position) (point)
       (list 'field t
             'rear-nonsticky t))))

  (defun +eshell-global-history-init ()
    "Share the eshell history ring between the eshell buffers.
  Addice add this :after `eshell-hist-initialize`"
    (or (boundp 'eshell-global-history-ring)
        (setq eshell-global-history-ring (ring-copy eshell-history-ring)))
    (setq eshell-history-ring eshell-global-history-ring))

  (use-package eshell
    :hook ((eshell-first-time-mode . eshell-mode-configuration)
           (eshell-directory-change . +eshell-rename)
           (eshell-after-prompt . +eshell-make-field)
           (eshell-mode . (lambda ()
                            ;; imenu support for eshell
                            (setq-local imenu-generic-expression '(("$ " " $ \\(.*\\)" 1))))))
    :init
    (setq eshell-hist-ignoredups t
          eshell-save-history-on-exit t
          eshell-destroy-buffer-when-process-dies t)

    (setenv "PAGER" "cat")

    ;; TODO remove the follwing if not needed
    ;;(advice-add '+emacs/split-follow-window-horizontally :after #'eshell-after-split)
    ;;(advice-add '+emacs/split-follow-window-vertically :after #'eshell-after-split)
    (advice-add 'eshell-hist-initialize :after #'+eshell-global-history-init)

    (leader-key "e" '+eshell)
    (leader-key "E" '+eshell-other-window)
    (leader-key "pe" '+eshell-project)
    (leader-key "pE" '+eshell-project-other-window))

  (use-package eshell-syntax-highlighting
    :straight t ;; Install if not already installed.
    :config
    ;; Enable in all Eshell buffers.
    (eshell-syntax-highlighting-global-mode +1))
#+end_src

** Eshell functions
#+begin_src emacs-lisp
  (defun eshell/! (&rest args)
    (let ((cmd (mapconcat 'identity args " ")))
      (async-shell-command cmd)))

  (defun eshell/ff (&rest args)
    (apply #'find-file args))

  (defun eshell/awswhoami (&rest args)
    (let ((profile (getenv "AWS_PROFILE")))
      (message (if (null profile) "default" profile))))

  (defun slurp (f)
    (with-temp-buffer
      (insert-file-contents f)
      (buffer-substring-no-properties
       (point-min)
       (point-max))))

  (defun eshell/awsprofile (&rest args)
    (require 'seq)
    (let* ((matches (seq-filter (apply-partially 'string-match "\^\[*.\]\$")
                                (split-string (slurp "~/.aws/credentials"))))
           (trim (seq-map (lambda (x) (string-trim x "\\[" "\\]")) matches))
           (choice (ivy-read "AWS Profile: " trim)))
      (setenv "AWS_PROFILE" choice)))
#+end_src

** Proc-hist
#+begin_src  emacs-lisp
  (use-package proc-hist
    :straight (proc-hist :type git :host github :repo "svaante/proc-hist")
    :config
    (proc-hist-mode)

    (defvar-keymap embark-proc-hist-actions-map
      :doc "Proc hist actions"
      :parent embark-general-map
      "k" #'proc-hist-kill
      "r" #'proc-hist-rerun
      "R" #'proc-hist-rerun-as
      "w" #'proc-hist-copy-as-kill-command)

      (add-to-list 'embark-keymap-alist '(proc-hist . embark-proc-hist-actions-map))

    (leader-key
      "d" 'proc-hist-dwim))
#+end_src

** Shell-mode
#+begin_src emacs-lisp
  (defun kill-on-no-process ()
    (interactive)
    (if (null (get-buffer-process (current-buffer)))
        (kill-buffer)
      (quit-window)))

  (use-package shell
    :straight (:type built-in)
    :config
    (setq evil-normal-state-modes (append evil-normal-state-modes '(shell-mode)))
    (evil-define-key 'normal shell-mode-map "q" 'kill-on-no-process)

    (define-key embark-file-map "!" 'async-shell-command)
    (setq async-shell-command-buffer 'rename-buffer)
    (setq shell-command-prompt-show-cwd t)

    (leader-key
      "!" 'async-shell-command))
#+END_SRC

** Async shell command
#+begin_src emacs-lisp
  (advice-add 'read-shell-command
              :around
              (defun read-shell-command-default (read-shell-command
                                                 prompt
                                                 &optional initial-contents hist
                                                 &rest args)
                "Advice for `read-shell-command', use last hist as default."
                (let ((last-command (and (not hist)
                                         (car shell-command-history))))
                  (when (and last-command (stringp last-command))
                    (let ((insert-point (or (string-match-p ": $" prompt)
                                            (length prompt))))
                      (setq prompt
                            (concat (substring prompt 0 insert-point)
                                    (format " (%s)"
                                            (propertize last-command
                                                        'face '(t :inherit highlight
                                                                  :slant italic)))
                                    (substring prompt insert-point)))))
                  (or (apply read-shell-command prompt initial-contents hist
                             args)
                      (and (setq (cons last-command shell-command-history))
                           last-command)))))

  (advice-remove 'read-shell-command 'read-shell-command-default)
#+end_src

* Misc
** wgrep
Change stuff in the grep buffer
#+begin_src emacs-lisp
  (use-package wgrep :straight t)
#+end_src

** ediff
#+begin_src emacs-lisp
  (use-package ediff
    :straight (:type built-in)
    :config
    (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

** Writing
#+begin_src emacs-lisp
  (defun +ispell-toogle-english-swedish-dictonary ()
    "Toggle `Ispell dictionary between English and Swedish."
    (interactive)
    (when (bound-and-true-p flyspell-mode)
      (cond
       ((string-equal ispell-local-dictionary flyspell-default-dictionary)
        (ispell-change-dictionary "swedish"))
       ((string-equal ispell-local-dictionary "swedish")
        (ispell-change-dictionary flyspell-default-dictionary))
       (t
        (ispell-change-dictionary flyspell-default-dictionary)))))

  (use-package flyspell
    :straight t
    ;;inside git commit and markdown
    :hook ((git-commit-mode org-mode markdown-mode) . flyspell-mode)
    :config
    (setq flyspell-default-dictionary "english")

    (defun +flyspell-programing-english ()
      (interactive)
      (ispell-change-dictionary flyspell-default-dictionary)
      (flyspell-prog-mode))

    (leader-key
      "ff" '+ispell-toogle-english-swedish-dictonary
      "fp" '+flyspell-programing-english))

  (use-package define-word
    :straight t
    :config
    (leader-key "fd"
      'define-word-at-point))

  (use-package mail-mode
    :straight (:type built-in)
    :hook ((mail-mode . auto-fill-mode)
           (mail-mode . (lambda ()
                          (setq-local fill-column 70)))))
#+end_src

** Dedicated windows
#+begin_src emacs-lisp
  (defun toggle-window-dedicated ()
    "Toggle window dedicated"
    (interactive)
    (set-window-dedicated-p (selected-window)
                            (not (window-dedicated-p))))

  (leader-key "wl" 'toggle-window-dedicated)

  (defun kill-dedicated-windows ()
    "Kill all dedicated windows"
    (interactive)
    (seq-do (lambda (window)
              (when (window-dedicated-p window)
                (quit-window nil window)))
            (window-list)))

  (leader-key "wq" 'kill-dedicated-windows)
#+END_SRC

** Scratch
#+begin_src emacs-lisp
  ;; Eval code lisp in the *scratch* buffer
  (define-key lisp-interaction-mode-map (kbd "C-c C-c") 'eval-buffer)
#+end_src

** Useful functions
#+begin_src emacs-lisp
  (defun +zoom-window ()
    (interactive)
    (if (and (= 1 (count-windows))
             (bound-and-true-p zoomed-window-configuration))
        (let ((buffer (current-buffer)))
          (set-window-configuration zoomed-window-configuration)
          (switch-to-buffer buffer))
      (setq-local zoomed-window-configuration (current-window-configuration))
      (delete-other-windows)))

  (define-key evil-normal-state-map "\C-wo" '+zoom-window)
  (define-key evil-emacs-state-map "\C-wo" '+zoom-window)
  (define-key evil-visual-state-map "\C-wo" '+zoom-window)

  ;; source: http://steve.yegge.googlepages.com/my-dot-emacs-file
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive (list (read-string "New name: " (buffer-name (current-buffer)))))
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (progn
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil))))))

  (defun scratch-from-mode (mode)
    "Create scratch buffer for major MODE."
    (interactive
     (list
      (intern
       (completing-read "Mode: "
                        (mapcar 'cdr
                                auto-mode-alist)
                        nil t))))
    (let ((buffer
           (get-buffer-create (format "*scratch: %s*"
                                      (symbol-name mode)))))
      (with-current-buffer buffer
        (funcall-interactively mode))
      (pop-to-buffer-same-window buffer)))

  (defun load-last-theme ()
    (when (and consult--theme-history)
      (dolist (theme custom-enabled-themes)
        (disable-theme theme))
      (load-theme (intern (car consult--theme-history)) t)))

  (eval-after-load "savehist"
    (add-hook 'savehist-mode-hook 'load-last-theme))
#+end_src

* Programming
** Progn mode
#+begin_src emacs-lisp
  (use-package prog-mode
    :straight (:type built-in)
    :config
    (evil-define-key 'normal prog-mode-map "gr" 'xref-find-references)
    (evil-define-key 'normal prog-mode-map "gD" 'xref-find-definitions-other-window)
    (define-key prog-mode-map (kbd "C-;") 'comment-dwim)

    (setq xref-prompt-for-identifier
          '(not xref-find-definitions
                xref-find-definitions-other-window
                xref-find-definitions-other-frame
                xref-find-references)))
#+end_src

** Flymake
#+begin_src emacs-lisp
  (use-package flymake
    :straight (:type built-in))
#+end_src

** 80 Columns
#+begin_src emacs-lisp
  (use-package display-fill-column-indicator
    :straight (:type built-in)
    :hook (prog-mode-hook . display-fill-column-indicator-mode)
    :config
    (setq display-fill-column-indicator-column 80))
#+end_src

** LSP
#+begin_src emacs-lisp
  (use-package lsp-snippet-tempel
    :straight (lsp-snippet-tempel :type git
                                  :host github
                                  :repo "svaante/lsp-snippet")
    :config
    (lsp-snippet-tempel-eglot-init))

  (use-package lsp-snippet-yasnippet
    :disabled
    :straight (lsp-snippet-yasnippet :type git
                                     :host github
                                     :repo "svaante/lsp-snippet")
    :config
    (lsp-snippet-yasnippet-eglot-init))

  ;; Testing
  (use-package yasnippet
    :disabled
    :straight (yasnippet :type git
                         :host github
                         :repo "joaotavora/yasnippet")
    :hook (eglot-managed-mode . yas-minor-mode)
    :config
    ;; Disable yas snippet if completion-in-region active in corfu mode
    (setq yas-keymap-disable-hook
          (lambda (&rest _)
            (and corfu-mode completion-in-region-mode))))


  (use-package lsp-mode
    :disabled
    :straight t)
    ;:hook (prog-mode . (lambda ()
    ;                     (unless (derived-mode-p 'clojure-mode
    ;                                             'emacs-lisp-mode
    ;                                             'lisp-mode
    ;                                             'snippet-mode)
    ;                       (lsp-deferred))))
    ;:hook (lsp-mode . (lambda ()
    ;                    (setq-local evil-lookup-func 'lsp-describe-thing-at-point)))
    ;:config
    ;(setq lsp-file-watch-threshold 1000)
    ;(setq lsp-headerline-breadcrumb-enable nil)
    ;(setq lsp-modeline-code-actions-enable nil)
    ;(setq lsp-modeline-diagnostics-enable nil)
    ;(setq lsp-lens-enable nil)
    ;(setq lsp-completion-provider :none)
    ;(setq lsp-completion-enable nil)

    ;; enable lsp-mode inside of org babel edit src blocks
    (defun org-babel-edit-prep:python (babel-info)
      (setq-local buffer-file-name (->> babel-info caddr (alist-get :tangle))))

    ;; c mode configurations
    ;;(setq lsp-clients-clangd-args
    ;;      '("-j=2"
    ;;        "--background-index"
    ;;        "--clang-tidy"
    ;;        "--completion-style=bundled"
    ;;        "--pch-storage=memory"
    ;;        "--header-insertion=never"
    ;;        "--header-insertion-decorators=0"))

    ;; (leader-key
    ;;   "lr" 'lsp-rename
    ;;   "lf" 'lsp-format-buffer))

  (use-package consult-lsp
    :disabled
    :after lsp-mode
    :straight t
    :config
    (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols)
    (leader-key
      "ls" 'consult-lsp-symbols))
#+end_src

** Eglot
#+begin_src emacs-lisp
  ;; out of sync errors between eglot and corfu
  (use-package jsonrpc
    :straight t)

  (use-package eglot
    :straight (eglot :type git :host github :repo "joaotavora/eglot")
    :hook ((c-mode . eglot-ensure)
           (c++-mode . eglot-ensure)
           (rust-mode . eglot-ensure)
           (go-mode . eglot-ensure)
           (python-mode . eglot-ensure)
           (csharp-mode . eglot-ensure))
    :config
    ;; BUG: https://github.com/joaotavora/eglot/issues/1171
    (add-hook 'eglot-managed-mode-hook
              (lambda () (setq eldoc-documentation-functions
                               '(flymake-eldoc-function
                                 eglot-signature-eldoc-function
                                 eglot-hover-eldoc-function))))

    (setq eglot-ignored-server-capabilities '(:codeLensProvider))

    (leader-key
      "la" 'eglot-code-actions
      "lr" 'eglot-rename
      "lf" 'eglot-format-buffer
      "lq" 'eglot-code-action-quickfix
      "la" 'eglot-code-actions))

  (use-package consult-eglot
    :after eglot
    :straight t
    :config
    (leader-key "ls" 'consult-eglot-symbols))
#+END_SRC

** Emacs lisp
#+begin_src emacs-lisp
  ;; Stolen from http://www.sugarshark.com/elisp/init/lisp.el.html
  (defun describe-elisp-thing-at-point ()
    "Show the documentation of the Elisp function and variable near point.
          This checks in turn:
          -- for a function name where point is
          -- for a variable name where point is
          -- for a surrounding function call
          "
    (interactive)
    (let (sym)
      ;; sigh, function-at-point is too clever.  we want only the first half.
      (cond ((setq sym (ignore-errors
                         (with-syntax-table emacs-lisp-mode-syntax-table
                           (save-excursion
                             (or (not (zerop (skip-syntax-backward "_w")))
                                 (eq (char-syntax (char-after (point))) ?w)
                                 (eq (char-syntax (char-after (point))) ?_)
                                 (forward-sexp -1))
                             (skip-chars-forward "`'")
                             (let ((obj (read (current-buffer))))
                               (and (symbolp obj) (fboundp obj) obj))))))
             (describe-function sym))
            ((setq sym (variable-at-point)) (describe-variable sym))
            ;; now let it operate fully -- i.e. also check the
            ;; surrounding sexp for a function call.
            ((setq sym (function-at-point)) (describe-function sym)))))

  (use-package elisp-mode
    :straight (:type built-in)
    :config
    (seq-do
     (lambda (mode-map)
       (evil-define-key 'normal mode-map
         (kbd "K")
         'describe-elisp-thing-at-point)
       (evil-define-key '(normal insert) mode-map
         (kbd "C-c C-e") 'eval-defun)
       (evil-define-key '(normal insert) mode-map
         (kbd "C-c C-c") 'eval-buffer)
       (evil-define-key 'visual mode-map
         (kbd "C-c C-c") 'eval-region))
     (list emacs-lisp-mode-map lisp-interaction-mode-map)))

  (use-package eros
    :straight t
    :config
    (eros-mode))
#+end_src

** Readable data files
#+begin_src emacs-lisp
  (use-package yaml-mode :straight t)

  (use-package json-mode :straight t)

  (use-package csv-mode
    :straight t
    :hook ((csv-mode . csv-align-mode)
           (csv-mode . csv-highlight))
    :config

    (defun csv-highlight (&optional separator)
      (interactive (list (when current-prefix-arg (read-char "Separator: "))))
      (font-lock-mode 1)
      (let* ((separator (or separator ?\,))
             (n (count-matches (string separator) (point-at-bol) (point-at-eol)))
             (colors (cl-loop for i from 0 to 1.0 by (/ 2.0 n)
                              collect (apply #'color-rgb-to-hex
                                             (color-hsl-to-rgb i 0.3 0.5)))))
        (cl-loop for i from 2 to n by 2
                 for c in colors
                 for r = (format "^\\([^%c\n]+%c\\)\\{%d\\}" separator separator i)
                 do (font-lock-add-keywords nil `((,r (1 '(face (:foreground ,c))))))))))
#+end_src

** Go
#+begin_src emacs-lisp
  (use-package go-mode :straight t)
#+end_src

** Clojure
#+begin_src emacs-lisp
  (use-package clojure-mode :straight t :defer t)
  (use-package cider :straight t :defer t)
#+end_src

** C
#+begin_src emacs-lisp
  (use-package cc-mode
    :straight (:type built-in)
    :config
    (setq c-basic-offset 4))
#+end_src

** Common lisp
#+begin_src emacs-lisp
  (use-package sly
    :straight t
    :config
    (setq sly-command-switch-to-existing-lisp 'always))
#+end_src

** Javascript
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (setq js-indent-level 2))

  (use-package web-mode
    :straight t
    :defer t
    :custom
    (web-mode-markup-indent-offset 2)
    (web-mode-css-indent-offset 2)
    (web-mode-code-indent-offset 2)
    :config
    (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
    (add-to-list 'auto-mode-alist '("\\.jsx?$" . web-mode)))

  (use-package add-node-modules-path :straight t)

  (use-package nodejs-repl
    :straight t
    :config
    ;; https://github.com/abicky/nodejs-repl.el/issues/37
    (defun +nodejs-repl-remove-broken-filter ()
      (remove-hook 'comint-output-filter-functions 'nodejs-repl--delete-prompt t))

    (add-hook 'nodejs-repl-mode-hook #'+nodejs-repl-remove-broken-filter))
#+end_src

** Python
#+begin_src emacs-lisp
  (use-package lsp-pyright :straight t)

  (use-package with-venv
    :straight t)

  (use-package pyenv
    :straight t
    :config
    (pyenv-use-global))

  (defun +inferior-python-mode-init ()
    (advice-add 'python-shell-completion-at-point :around 'cape-wrap-purify)
    (advice-add 'python-shell-completion-at-point :around 'cape-wrap-noninterruptible)
    (setq-local completion-styles '(basic)))

  (use-package python
    :after cape
    :hook ((inferior-python-mode . +inferior-python-mode-init)
           (python-mode . hs-minor-mode))
    :config
    (setq python-flymake-command nil)
    (setq python-check-command nil)

    (defun +python-shell-send-dwm ()
      (interactive)
      (or (python-shell-get-process) (run-python))
      (if (use-region-p)
          (call-interactively 'python-shell-send-region)
        (call-interactively 'python-shell-send-buffer)))

    (setq python-shell-interpreter "ipython3"
          python-shell-interpreter-args "-i --simple-prompt"
          python-shell-completion-native-enable nil)

    (define-key python-mode-map (kbd "C-c C-c") '+python-shell-send-dwm))
#+end_src

** Typescript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :straight t
    :config
    (setq-default typescript-indent-level 2))
#+end_src

** Rust
#+begin_src emacs-lisp
  (use-package rustic
    :disabled
    :straight t
    :config
    ;; Remove auto formating which caused isses with trying to save all buffers
    (advice-remove 'save-some-buffers 'rustic-save-some-buffers-advice)

    ;; Use rustic compilation mode stuff outside of rustic-compilation mode
    (add-hook 'compilation-filter-hook #'rustic-insert-errno-button nil)
    (add-to-list 'compilation-error-regexp-alist-alist
                 (cons 'rustic-error rustic-compilation-error))
    (add-to-list 'compilation-error-regexp-alist-alist
                 (cons 'rustic-warning rustic-compilation-warning))
    (add-to-list 'compilation-error-regexp-alist-alist
                 (cons 'rustic-info rustic-compilation-info))
    (add-to-list 'compilation-error-regexp-alist-alist
                 (cons 'rustic-panic rustic-compilation-panic))
    (add-to-list 'compilation-error-regexp-alist 'rustic-error)
    (add-to-list 'compilation-error-regexp-alist 'rustic-warning)
    (add-to-list 'compilation-error-regexp-alist 'rustic-info)
    (add-to-list 'compilation-error-regexp-alist 'rustic-panic))

  (use-package rust-mode
    :straight t)
#+end_src

** Godot
#+begin_src emacs-lisp
  (use-package gdscript-mode
    :straight t
    :config
    (setq gdscript-use-tab-indents nil)
    (setq gdscript-indent-offset 4))
#+end_src

** Dart
#+begin_src emacs-lisp
  (use-package dart-mode
    :straight t)
#+end_src

** Devdocs
#+begin_src  emacs-lisp
  (defun devdocs-lookup-ask-docs ()
    (interactive)
    (devdocs-lookup t))

  (use-package devdocs
    :straight t
    :config
    (leader-key "k" 'devdocs-lookup)
    (leader-key "K" 'devdocs-lookup-ask-docs))

  (use-package eldoc
    :straight (:type built-in)
    :config
    (setq eldoc-echo-area-use-multiline-p 1))
#+end_src

** Compilation
#+begin_src emacs-lisp
  (use-package xterm-color
    :straight t
    :config
    (setq compilation-environment '("TERM=xterm-256color"))

    (defun xterm-color-advice-compilation-filter (f proc string)
      (funcall f proc (xterm-color-filter string)))

    (advice-add 'compilation-filter :around #'xterm-color-advice-compilation-filter))

  (use-package compile
    :straight (:type built-in)
    :config
    ;; Use last history as the compile command
    (setq compile-command (or (car-safe compile-history) ""))
    ;; Always scroll
    (setq compilation-scroll-output t)
    ;; Just save me the keystrokes
    (setq compilation-ask-about-save nil)

    (evil-define-key 'normal compilation-minor-mode-map
      (kbd "<tab>") 'compilation-next-file
      (kbd "<backtab>") 'compilation-previous-file))
#+end_src

** Dape Debugging
#+begin_src emacs-lisp
  (use-package dape
    ;;:straight (dape :type git :host github :repo "svaante/dape")
    :straight (:local-repo "~/Workspace/dape/")
    :init
    ;; (setq dape-buffer-window-arrangment 'gud)
    :config
    (add-hook 'dape-compile-compile-hooks 'kill-buffer)

    (add-hook 'dape-on-start-hooks (defun dape--save-on-start ()
                                     (save-some-buffers t t)))

    (remove-hook 'dape-on-start-hooks 'dape-info)
    (add-hook 'dape-on-stopped-hooks 'dape-info)

    (dape-breakpoint-global-mode)

    (setq dape-buffer-window-arrangment 'right)

    (leader-key "pd" '(:keymap dape-global-map :which-key "dape")))

  (use-package dape-configs
    :disabled
    :straight (:local-repo "~/Workspace/dape-configs/")
    ;;:straight (dape-configs :type git :protocol ssh :host github :repo "svaante/dape-configs")
    :config
    ;;(setq dape-configs (assq-delete-all 'lldb-vscode dape-configs))
    )
#+end_src
* Applications
** Dired
#+begin_src emacs-lisp
  (use-package dired
    :straight (:type built-in)
    :hook (dired-mode . auto-revert-mode)
    :config
    ;; If two dired opened use other dired default-directory as
    ;; base target
    (setq dired-dwim-target t)

    (when (eq system-type 'darwin)
      (setq dired-use-ls-dired nil))

    (defun dired-here-other-window ()
      (interactive)
      (dired-other-window default-directory))

    (defun dired-here ()
      (interactive)
      (dired default-directory))

    (leader-key "ad" 'dired-here
                "aD" 'dired-here-other-window))

  (use-package diredfl
    :straight t
    :hook (dired-mode . diredfl-mode))

  (use-package dired-subtree
    :straight t
    :config
    (setq dired-subtree-line-prefix "    "))
#+end_src

** Magit
#+begin_src emacs-lisp
  (use-package magit
    :straight t
    :config
    (setq evil-insert-state-modes (append evil-insert-state-modes '(git-commit-mode)))

    (defun magit-status-here-and-center ()
      (interactive)
      (magit-status-here)
      (recenter))

    ;; Don't let magit close windows
    (setq magit-bury-buffer-function 'bury-buffer)

    (leader-key "gg" 'magit-status-here-and-center)
    (leader-key "g." 'magit-find-file)
    (leader-key "gd" 'magit-diff)
    (leader-key "gb" 'magit-blame)
    (leader-key "gl" 'magit-log)
    (leader-key "gc" 'magit-checkout)
    (leader-key "gf" 'magit-fetch-all)
    (leader-key "gf" 'magit-log-buffer-file))

#+end_src

** Tramp
#+begin_src emacs-lisp
  (use-package tramp
    :init
    (setq tramp-default-method "ssh"))
#+end_src

** Proced/top
#+BEGIN_SRC emacs-lisp
  (use-package proced
    :straight (:type built-in)
    :config
    (setq proced-enable-color-flag t)

    (defun eshell/top (&rest args)
      (proced))

    (leader-key "ap" #'proced))
#+END_SRC

** Postman
#+begin_src emacs-lisp
  (use-package restclient
    :straight t
    :config
    (setq restclient-buffer-name "*restclient*")

    (defun create-restclient-mode-buffer ()
      (interactive)
      (let ((buffer-exist (get-buffer restclient-buffer-name)))
        (switch-to-buffer-other-window restclient-buffer-name)
        (unless buffer-exist
          (with-current-buffer (get-buffer restclient-buffer-name)
            (unless (bound-and-true-p restclient-mode)
              (progn
                (restclient-mode)
                (insert
                 "Welcome to restclient-mode!\n"
                 "Execute with: C-c C-c\n"
                 "\n"
                 "POST https://httpbin.org/post\n"
                 "Content-Type: application/json\n"
                 "{\n"
                 "   \"key\": \"value\"\n"
                 "}\n")))))
      (goto-char (point-max))
      (evil-insert-state)))

    (defun restclient-buffer-quit ()
      (interactive)
      (delete-windows-on restclient-buffer-name)
      (bury-buffer restclient-buffer-name))

    (evil-define-key 'normal restclient-mode-map
      "q" 'restclient-buffer-quit)

    (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode))

    (leader-key "ah" 'create-restclient-mode-buffer))
#+end_src

** Calc
#+begin_src emacs-lisp
  (use-package literate-calc-mode
    :straight t
    :config
    (setq literate-calc-buffer-name "*literate-calc*")
    (setq literate-calc-mode-idle-time 0.1)

    (defun create-literate-calc-mode-buffer ()
      (interactive)
      (let* ((buffer-exist (get-buffer literate-calc-buffer-name))
             (window-exist (and buffer-exist (get-buffer-window buffer-exist))))
        (if window-exist
            (select-window window-exist)
          (switch-to-buffer-other-window literate-calc-buffer-name)
          (unless buffer-exist
            (with-current-buffer (get-buffer literate-calc-buffer-name)
              (unless (bound-and-true-p literate-calc-mode)
                (progn
                  (literate-calc-mode)
                  (insert
                   "Welcome to literate-calc-mode!\n"
                   "\n"
                   "= "))))))
        (goto-char (point-max))
        (evil-insert-state)))

    (defun literate-calc-buffer-quit ()
      (interactive)
      (delete-windows-on literate-calc-buffer-name)
      (bury-buffer literate-calc-buffer-name))

    (evil-define-key 'normal literate-calc-mode-map
      "q" 'literate-calc-buffer-quit)

    (leader-key "ac"
      'create-literate-calc-mode-buffer))
#+end_src

** Jupyter notebooks
#+begin_src emacs-lisp
  (use-package ein
    :straight t
    :config
    (setq ein:polymode t))
#+end_src

** Elfeed
#+begin_src emacs-lisp
  (defun elfeed-open-and-refresh ()
    (interactive)
    (elfeed)
    (elfeed-update))

  (use-package elfeed
    :straight t
    :config
    (leader-key "ar" 'elfeed-open-and-refresh)
    (setq elfeed-feeds
          '(("https://lithub.com/feed/" kultur)
            ("https://hnrss.org/newest?points=50" tech)
            ("https://us-east1-ml-feeds.cloudfunctions.net/arxiv-ml-reviews" ml)
            ("http://api.sr.se/api/rss/channel/83?format=1" nyheter)))

    (evil-define-key 'normal elfeed-show-mode-map
      "p" 'elfeed-show-prev
      "n" 'elfeed-show-next))
#+end_src

** Email
*** Gnus
#+begin_src emacs-lisp
  (use-package gnus
    :config
    (setq epa-pinentry-mode 'loopback))
#+end_src

** Chatgpt
#+begin_src emacs-lisp
  (use-package gptel
    :straight (gptel :type git :host github :repo "karthink/gptel")
    :config
    (define-key gptel-mode-map (kbd "C-c C-c") 'gptel-send)
    (when (file-exists-p (locate-user-emacs-file "gpt-api-key.el"))
      ;; (setq gptel-api-key "key")
      (load-file (locate-user-emacs-file "gpt-api-key.el")))
    (leader-key "aa" 'gptel))
#+end_src
