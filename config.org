#+TITLE: Emacs package configuration file
#+PROPERTY: header-args    :results silent

* Basic
#+BEGIN_SRC emacs-lisp
  ;; this is what the man told me to for native compilation
  (setq comp-speed 2)
  (setq package-native-compile t)
  ;; HACK https://github.com/hlissner/doom-emacs/issues/4400
  (setq native-comp-deferred-compilation-deny-list nil)
  ;; remove native comp errors
  (setq native-comp-async-report-warnings-errors nil)

  ;; remove gui elements
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)

  ;; set fringe style to minimal
  (set-fringe-style 0)

  ;; remove visual bell
  (setq visible-bell       nil
        ring-bell-function #'ignore)

  ;; set default dir to home
  (setq default-directory "~/")

  ;; follow symlinks
  (setq vc-follow-symlinks t)

  ;; spaces not tabs
  (setq-default indent-tabs-mode nil)

  ;; no backup files
  (setq make-backup-files nil)
  (global-auto-revert-mode t)

  ;; y/n will do
  (defalias 'yes-or-no-p 'y-or-n-p)
  (setq use-short-answers t)

  ;; stop the insessent blinking
  (blink-cursor-mode 0)

  ;; Backup trails is worse then chem-trails, losing patches is 99% of the time my fault
  (setq auto-save-default nil)

  ;; perf
  (setq gc-cons-threshold 100000000)
  (setq read-process-output-max (* 1024 1024))

  ;; Remove that pesky help window
  (setq inhibit-startup-screen t)

  ;; Prefer vertical splits over horizontal splits
  (setq split-width-threshold 160)
  (setq split-height-threshold 90)

  ;; Resize frames based on pixels
  (setq frame-resize-pixelwise t)

  ;; Ignore defvaralias warnings
  (add-to-list 'warning-suppress-types '(defvaralias))
 #+END_SRC

* Platform
** Mac
#+BEGIN_SRC  emacs-lisp
  (when (eq system-type 'darwin)
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    (setq mac-option-key-is-meta t)
    (setq mac-right-option-modifier nil))
#+END_SRC

** Linux
#+begin_src emacs-lisp
  (when (eq system-type 'gnu/linux)
    (global-set-key (kbd "C-+") 'text-scale-increase)
    (global-set-key (kbd "C--") 'text-scale-decrease))
#+end_src

* Package
#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (setq package-enable-at-startup nil)

  (straight-use-package 'use-package)
  (straight-use-package 'el-patch)
#+end_src

#+begin_src emacs-lisp
  (use-package diminish
    :straight t
    :after use-package)
#+end_src

* Key mappings

** Global mappings
#+begin_src emacs-lisp
  (use-package emacs
    :after evil
    :config
    (defun +emacs/split-follow-window-vertically ()
      "Split and follow window vertically."
      (interactive)
      (split-window-vertically) (other-window 1))

    (defun +emacs/split-follow-window-horizontally ()
      "Split and follow window horizontally."
      (interactive)
      (split-window-horizontally) (other-window 1))

    ;; create my own global intercept map for global evil keybindings
    (defvar global-intercept-mode-map (make-sparse-keymap)
      "High precedence keymap.")

    (define-minor-mode global-intercept-mode
      "Global minor mode for higher precedence keybindings."
      :global t)

    (global-intercept-mode)

    (dolist (state '(normal visual insert))
      (evil-make-intercept-map
       ;; NOTE: This requires an evil version from 2018-03-20 or later
       (evil-get-auxiliary-keymap global-intercept-mode-map state t t)
       state))

    ;; HACK: To seperate C-i with <tab> in terminal <Tab> is more important then C-i
    (when (display-graphic-p)
      (define-key input-decode-map (kbd "C-i") (kbd "H-i")))

    (evil-define-key '(normal insert) global-intercept-mode-map
      "\C-j" 'evil-window-down
      "\C-k" 'evil-window-up
      "\C-h" 'evil-window-left
      "\C-l" 'evil-window-right
      (kbd "H-i") 'evil-jump-forward
      "\C-o" 'evil-jump-backward
      "\C-ws" '+emacs/split-follow-window-vertically
      "\C-wv" '+emacs/split-follow-window-horizontally))
#+end_src

** Evil
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :straight t
    :diminish
    :config
    (setq undo-tree-auto-save-history nil)
    (global-undo-tree-mode 1))

  (use-package evil
    :straight t
    :init
    (setq evil-mode-line-format nil)
    (setq evil-want-C-i-jump nil)
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-Y-yank-to-eol t)
    (setq evil-want-C-u-scroll t)
    (setq evil-search-module 'evil-search)
    (setq evil-want-minibuffer t)
    (setq evil-undo-system 'undo-tree)
    (setq evil-jumps-cross-buffers t)
    (setq evil--jumps-buffer-targets  "\\*\\(.+\\)\\*")
    (setq evil-insert-state-message nil)
    (setq evil-normal-state-message nil)
    (setq-default evil-symbol-word-search t)
    (setq-default evil-shift-width 2)
    :config
    ;; use symbols instead of words when using the vim subject "word"
    (defalias #'forward-evil-word #'forward-evil-symbol)

    ;; run the macro in the q register
    (evil-define-key 'normal 'global "Q" "@q")

    ;; Keep eldoc message on insert
    (eldoc-add-command 'evil-change)
    (eldoc-add-command 'evil-insert)

    ;; my common misspellings
    (evil-ex-define-cmd "E[dit]" 'evil-edit)
    (evil-ex-define-cmd "W[rite]" 'evil-write)
    (evil-ex-define-cmd "Wq" 'evil-save-and-close)
    (evil-ex-define-cmd "WQ" 'evil-save-and-close)
    (evil-ex-define-cmd "Wq" 'evil-save-and-close)
    (evil-ex-define-cmd "Qa[ll]" "quitall")
    (evil-ex-define-cmd "qA[ll]" "quitall")
    (evil-ex-define-cmd "QA[ll]" "quitall")
    (evil-mode 1))

  (use-package evil-surround
    :straight t
    :config
    (global-evil-surround-mode 1))

  (use-package evil-escape
    :diminish
    :straight t
    :init
    (setq evil-escape-delay 0.2)
    (setq evil-escape-unordered-key-sequence t)
    (setq-default evil-escape-key-sequence "jk")
    :config
    (evil-escape-mode))

  (use-package evil-collection
    :after evil diminish
    :straight t
    :config
    ;; magit uses 'C-i' as tab like GUI emacs doesn't exist
    (evil-define-key 'normal magit-mode-map (kbd "<tab>") #'magit-section-cycle)

    (thread-last evil-collection-mode-list
                 (remove 'eshell)
                 (setq evil-collection-mode-list))
    (evil-collection-init)
    (diminish 'evil-collection-unimpaired-mode))

  (use-package evil-org
    :diminish
    :defer t
    :straight t
    :after org
    :hook ((org-mode . evil-org-mode)
           (evil-org-mode . (lambda ()
                              (evil-org-set-key-theme '(textobjects
                                                        insert
                                                        return
                                                        return
                                                        additional
                                                        shift
                                                        todo))))))
#+END_SRC

** Leader mappings
#+BEGIN_SRC emacs-lisp
  (use-package general
    :straight t
    :after evil
    :config
    (general-create-definer leader-key
      :prefix "SPC"
      :states '(normal emacs motion visual)
      :keymaps 'override))
#+END_SRC

** Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :straight t)
#+end_src

* Window
** Ace window
#+begin_src emacs-lisp
  (use-package ace-window
    :straight t
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (leader-key "jw" 'ace-window))
#+end_src

** Shackle
#+begin_src emacs-lisp
  (use-package shackle
    :straight t
    :config
    (defun shackle-split-below (buffer alist plist)
      (let* ((frame (shackle--splittable-frame))
             (total-height (window-size (frame-root-window)))
             (ratio (or (plist-get plist :ratio) (plist-get plist :size)))
             (abs-size (round (* total-height ratio)))
             (window (split-window-below)))
        (prog1
            (window--display-buffer buffer window 'window)
          (when window
            (setq shackle-last-window window
                  shackle-last-buffer buffer)
            (window-resize window (- abs-size (window-size window)))
            (set-window-dedicated-p window t))
          (unless (cdr (assq 'inhibit-switch-frame alist))
            (window--maybe-raise-frame frame)))))

    (defun +shackle-dedicate-popup (buffer alist plist)
      (when (and (plist-get plist :dedicated)
                 (not (window-dedicated-p shackle-last-window)))
        (set-window-dedicated-p shackle-last-window t)))

    ;; shackle--display-buffer-aligned-window will be non nil on success
    (advice-add 'shackle--display-buffer-aligned-window
                :after-while
                '+shackle-dedicate-popup)

    (setq shackle-lighter "")
    (setq shackle-rules
          '((shell-mode
             :noselect nil
             :align right
             :size 80
             :dedicated t
             :popup t)
            (compilation-mode
             :noselect nil
             :align right
             :size 80
             :dedicated t
             :popup t)
            ("*Help*"
             :select t
             :align right
             :size 75
             :dedicated t
             :popup t)
            ("*devdocs*"
             :select t
             :align right
             :size 85
             :dedicated t
             :popup t)
            ("*Messages*"
             :select t
             :align below
             :size 0.30
             :dedicated t
             :popup t)
            ("\\*Embark Export Occur\\*"
             :regexp t
             :select t
             :align below
             :size 0.25
             :dedicated t
             :popup t)
            ("*xref*"
             :select t
             :align below
             :size 0.25
             :dedicated t
             :popup t)
            ("\\*Embark Export Grep\\*"
             :regexp t
             :select t
             :align below
             :size 0.25
             :dedicated t
             :popup t)
            ("*Org Select*"
             :select t
             :align below
             :popup t)
            ("CAPTURE-.*\\.org"
             :regexp t
             :align below
             :size 0.40
             :popup t)
            ("\\*Agenda Commands\\*"
             :regexp t
             :select t
             :size 0.25
             :custom shackle-split-below)
            ("\\*Org Agenda\\*" ;; this does not work for some reason
             :regexp t
             :select t
             :size 0.25
             :custom shackle-split-below)
            ("\\*literate-calc\\*"
             :regexp t
             :select t
             :size 0.25
             :dedicated t
             :custom shackle-split-below)
            ("\\*restclient\\*"
             :regexp t
             :select t
             :size 0.25
             :custom shackle-split-below)
            ("\\*Python\\*"
             :regexp t
             :select t
             :size 0.25
             :custom shackle-split-below)
            (magit-status-mode
             :select t
             :inhibit-window-quit t
             :same t)))

    (shackle-mode 1))
#+end_src

** Mappings
#+begin_src emacs-lisp
  (leader-key
    "w" '(:ignore t :which-key "Manage windows")
    "wt" 'toggle-frame-maximized
    "wm" 'toggle-frame-fullscreen)
#+end_src

* Looks
** Fonts
#+begin_src emacs-lisp
  ;; Set my font
  (when (eq system-type 'darwin)
    (set-face-attribute 'default nil :font "Monaco 14")
    (set-fontset-font t '(#x1f300 . #x1f5ff)
                      (font-spec :family "Apple Color Emoji" :size 12)))

  (when (eq system-type 'gnu/linux)
    (set-face-attribute 'default nil :font "Monaco 8")
    ;(set-face-attribute 'default nil :font "DejaVu Sans Mono 9")
    )
#+end_src


** Themes
#+BEGIN_SRC emacs-lisp
  (use-package ef-themes
    :straight (ef-themes :type git :host github :repo "protesilaos/ef-themes"))

  (use-package modus-themes
    :straight t
    :config
    (setq modus-themes-mode-line '(accented borderless 3d))
    (setq modus-themes-org-blocks 'tinted-background)
    (setq modus-themes-headings
          '((1 . section)
            (2 . rainbow-line)
            (t . rainbow-no-bold)))
    '(load-theme 'modus-operandi t)
    '(load-theme 'modus-vivendi t))

  (use-package grandshell-theme
    :straight t
    :config
    '(load-theme 'grandshell t))

  (use-package inkpot-theme
    :straight t)

  (use-package zenburn-theme
    :straight t)

  (use-package doom-themes :straight t)
#+END_SRC

** Mode-line
#+begin_src emacs-lisp
  (defun mode-line-file-path ()
    (when (buffer-file-name)
      (abbreviate-file-name
       (or (when-let* ((prj (project-project-root))
                       (prj-parent (file-name-directory
                                    (directory-file-name
                                     (expand-file-name prj)))))
             (file-relative-name
              (file-name-directory buffer-file-truename)
              prj-parent))
           default-directory))))

  (setq mode-line-defining-kbd-macro
        (propertize " Macro" 'face 'mode-line-emphasis))

  (setq mode-line-position-column-line-format '(" %l:%c"))

  (setq-default mode-line-format
                '((:eval (when (window-dedicated-p)
                           (propertize "DEDI " 'face 'mode-line-emphasis)))
                  "🌻"
                  mode-line-front-space
                  mode-line-mule-info
                  mode-line-client
                  mode-line-modified
                  mode-line-remote
                  mode-line-frame-identification
                  (:eval (mode-line-file-path))
                  mode-line-buffer-identification
                  " "
                  mode-line-position
                  (:propertize mode-name
                               face bold)
                  " "
                  vc-mode
                  mode-line-misc-info
                  mode-line-end-spaces))

  (column-number-mode 1)

  (diminish 'eldoc-mode)
#+end_src

** Match paren
#+begin_src  emacs-lisp
  (use-package paren
    :config
    (setq show-paren-style 'parenthesis)
    (setq show-paren-when-point-in-periphery nil)
    (setq show-paren-when-point-inside-paren nil)
    (setq show-paren-delay 0)
    (show-paren-mode +1))
#+end_src

** Whitespace
*** Show whitespace
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :straight (:type built-in)
    :diminish
    :hook (prog-mode . whitespace-mode)
    :init
    (setq whitespace-line-column 80) ;; limit line length
    (setq whitespace-style '(face lines-tail trailing)))
#+END_SRC

*** Delete whitespace
#+begin_src emacs-lisp
  (use-package ws-butler
    :straight t
    :diminish
    :config
    (ws-butler-global-mode))
#+end_src

** Dashboard
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :diminish
    :straight t
    :config
    (setq dashboard-items '((recents  . 10)
                            (bookmarks . 10)))
    (dashboard-setup-startup-hook))
#+END_SRC

** Visual lines
#+begin_src emacs-lisp
  (use-package simple
    :diminish
    (global-visual-line-mode t))
#+end_src

* Buffer navigation
** Narrow
#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first.  Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  (leader-key "z" 'narrow-or-widen-dwim)
#+END_SRC

** Avy
#+begin_src emacs-lisp
  (use-package avy
    :straight t
    :config
    (leader-key
      "jj" 'evil-avy-goto-char-timer
      "jl" 'evil-avy-goto-line))
#+end_src

* Org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight (:type built-in)
    :hook ((org-mode . org-indent-mode)
           (org-mode . visual-line-mode))
    :config
    (defun +org-confirm-babel-evaluate (lang body)
      (not (member lang '("sh" "emacs-lisp" "python"))))

    (setq org-link-frame-setup '((file . find-file))) ;; Open Link in same window
    (setq org-return-follows-link t)
    (setq org-babel-python-command "python3")
    (setq org-confirm-babel-evaluate '+org-confirm-babel-evaluate)
    (setq org-src-window-setup 'current-window)
    (setq org-startup-with-inline-images t)

    ;; Enable babel languages
    (org-babel-do-load-languages 'org-babel-load-languages
                                 '((shell . t)
                                   (python . t)))

    (evil-define-key 'normal org-mode-map
      (kbd "<RET>") 'org-return)

    (leader-key "os" 'org-store-link))

  (use-package org-agenda
    :config
    ;; Dont touch my windows
    (defun org-agenda-well-behaved (old-org-agenda &rest args)
      "Does not close the other opend window before opening the capture buffer"
      (interactive)
      (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
        (apply old-org-agenda args)))
    (advice-add 'org-agenda :around 'org-agenda-well-behaved)

    (setq org-agenda-breadcrumbs-separator "/")
    (setq org-agenda-prefix-format '((agenda .  "  %?-40 b")
                                     (todo .    "  %?-40 b")
                                     (tags .    "  %?-40 b")
                                     (search .  "  %?-40 b")))

    (setq org-todo-keywords
          '((sequence "TODO" "ACTIVE" "DONE")))

    ;; Replace the original agenda
    (setq org-agenda-custom-commands
          '(("A" "Agenda"
             ((todo "ACTIVE"
                    ((org-agenda-overriding-header "Active:")))
              (agenda)
              (tags "-hide+LEVEL>1-SCHEDULED={.+}/TODO"
                    ((org-agenda-overriding-header "Projects:")))
              (tags "+LEVEL=1-SCHEDULED={.+}-DEADLINE={.+}/TODO"
                    ((org-agenda-overriding-header "Todos:")))))))

    (defun org-agenda-custom ()
      (interactive)
      (org-agenda nil "A"))

    (leader-key
      "oa" 'org-agenda-custom
      "oA" 'org-agenda
      "ot" 'org-todo-list
      "ow" 'org-agenda-list)

    (setq org-agenda-files '("~/org/notes.org"
                             "~/org/pad.org"
                             "~/org/todo.org"))

    ;; Create files if they do not exist
    (seq-do (lambda (file)
              (unless (file-exists-p file)
                (message "File %s created at startup" file)
                (make-empty-file file)))
            org-agenda-files)

    ;; been trying to use evil-org's evil-agenda only result was pain
    (evil-set-initial-state 'org-agenda-mode 'normal)
    (evil-define-key 'normal org-agenda-mode-map
      (kbd "<RET>") 'org-agenda-goto
      "q" 'org-agenda-quit
      "r" 'org-agenda-redo
      "K" 'org-agenda-priority-up
      "J" 'org-agenda-priority-down
      "n" 'org-agenda-add-note
      "t" 'org-agenda-todo
      "#" 'org-agenda-set-tags
      "j" 'org-agenda-next-line
      "k" 'org-agenda-previous-line
      "f" 'org-agenda-later
      "b" 'org-agenda-earlier
      "e" 'org-agenda-set-effort
      "." 'org-agenda-goto-today
      "H" 'org-agenda-do-date-earlier
      "L" 'org-agenda-do-date-later))

  (use-package org-capture
    :config
    ;; Dont touch my windows
    (defun org-capture-well-behaved (old-org-capture &rest args)
      "Does not close the other opened window before opening the capture buffer"
      (interactive)
      (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
        (apply old-org-capture args)))
    (advice-add 'org-capture :around 'org-capture-well-behaved)

    (add-hook 'org-capture-mode-hook (lambda (&rest _) (evil-insert 1)))

    (setq org-agenda-follow-indirect t)
    (setq org-refile-use-outline-path 'file)
    (setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
    (setq org-outline-path-complete-in-steps nil)

    (setq org-capture-templates '(("p" "Pad" plain
                                   (file+olp+datetree "~/org/pad.org")
                                   "\n%?\n"
                                   :unnarrowed t)
                                  ("n" "Note" entry
                                   (file "~/org/notes.org")
                                   "* %?\n")
                                  ("t" "Todo" entry
                                   (file "~/org/todo.org")
                                   "* TODO %?\n")))
    (leader-key "oc" 'org-capture))

  (use-package org-modern
    :straight (org-modern :type git :host github :repo "minad/org-modern")
    :hook ((org-mode . org-modern-mode)
           (org-agenda-finalize . org-modern-agenda))
    :config
    ;; Some type of fix when using org-indent-mode
    (setq org-modern-block-fringe nil))

  (use-package org-modern-indent
    :straight
    (org-modern-indent :type git :host github :repo "jdtsmith/org-modern-indent")
    :config
    (add-hook 'org-mode-hook #'org-modern-indent-mode 90))
#+END_SRC

** Notes
#+begin_src emacs-lisp
    (use-package org-mono
      :after embark
      :diminish
      :straight (org-mono :type git :host github :repo "svaante/org-mono")
      :config
      (setq org-mono-files '("~/org/notes.org"
                             "~/org/pad.org"
                             "~/org/thoughts.org"
                             "~/.emacs.d/config.org"))

      (setq org-mono-advice-org-refile t)

      (leader-key "oo" 'org-mono-goto)

      (defvar-keymap embark-org-mono-actions-map
        :doc "Keymap for actions for org-mono."
        :parent embark-general-map
        "o" #'org-mono-goto-other-window
        "t" #'org-mono-todo
        "r" #'org-mono-rename
        "w" #'org-mono-refile-from
        "a" #'org-mono-archive
        "k" #'org-mono-delete-headline
        "c" #'org-mono-goto-headline-child
        "d" #'org-mono-time-stamp
        "b" #'org-mono-goto-backlinks)

      (add-to-list 'embark-keymap-alist '(org-mono . embark-org-mono-actions-map))

      (global-org-mono-mode))

    (use-package org-mono-consult
      :after consult
      :straight (org-mono-consult :type git :host github :repo "svaante/org-mono")
      :config
      (setq org-mono-completing-read-fn 'org-mono-consult-completing-read))
#+end_src

* Completion
** Basics
#+begin_src emacs-lisp
  (delete ".bin" completion-ignored-extensions)
  (setq completion-ignore-case t)
#+end_src

** Package company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :disabled
    :straight t
    :diminish company-mode
    :config
    (setq company-backends '(company-files company-capf))
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 2)
    (setq company-tooltip-align-annotations t)
    (setq company-global-modes '(not eshell-mode))
    (setq company-format-margin-function #'company-text-icons-margin)
    (setq company-selection-wrap-around t)
    (setq company-dabbrev-ignore-case nil)
    (setq company-dabbrev-downcase nil)

    ;; Something creept in during update where c-n/c-p would sometimes
    ;; trigger evil-complete-next/previous
    (defun evil-complete-next-company (func arg)
      (if (company--active-p)
          (call-interactively 'company-select-next)
        (funcall func arg)))

    (defun evil-complete-previous-company (func arg)
      (if (company--active-p)
          (call-interactively 'company-select-previous)
        (funcall func arg)))

    (advice-add 'evil-complete-next
                :around
                #'evil-complete-next-company)
    (advice-add 'evil-complete-previous
                :around
                #'evil-complete-previous-company)

    (define-key company-active-map (kbd "RET") nil)
    (define-key company-active-map (kbd "<return>") nil)
    (define-key company-active-map (kbd "TAB") 'company-complete)
    (define-key company-active-map (kbd "<tab>") 'company-complete)

    (global-company-mode 1))

  (use-package company-posframe
    :disabled
    :straight t
    :diminish
    :config
    (setq company-posframe-show-metadata nil)
    (setq company-posframe-show-indicator nil)
    (setq company-posframe-quickhelp-delay nil)
    (company-posframe-mode 1))
#+END_SRC

** Corfu
#+begin_src emacs-lisp
  (use-package corfu
    :straight (corfu :files (:defaults "extensions/*")
                     :includes (corfu-popupinfo corfu-history))
    :hook (evil-insert-state-exit . corfu-quit)
    :config
    (setq corfu-cycle t)
    (setq corfu-auto t)
    (setq corfu-preselect 'first)
    (setq corfu-quit-no-match t)
    (setq corfu-auto-prefix 2)
    (setq corfu-on-exact-match 'quit)

    ;; Orderless completion
    (setq corfu-separator ?s)
    (setq corfu-quit-at-boundary nil)

    ;; In eshell use tab to open corfu
    (setq corfu-excluded-modes '(eshell-mode))
    (add-hook 'eshell-mode-hook
              (lambda ()
                (setq-local corfu-auto nil)
                (corfu-mode)))

    (define-key corfu-map (kbd "RET") nil)
    (global-corfu-mode)

    (setq corfu-popupinfo-delay '(2.0 . 0.5))
    (corfu-popupinfo-mode)

    (corfu-history-mode))

  (use-package corfu-terminal
    :straight t
    :config
    (unless (display-graphic-p)
      (corfu-terminal-mode +1)))

  (use-package cape
    :straight t
    :hook ((lsp-mode . coruf-lsp-mode-completions)
           (eglot-managed-mode . coruf-eglot-completions))
    :init
    ;; Default completion at point additions
    (add-to-list 'completion-at-point-functions #'cape-history)

    (add-to-list 'completion-at-point-functions #'cape-file)

    (defun coruf-lsp-mode-completions ()
      (setq-local completion-at-point-functions
                  (cons #'tempel-complete
                        (list (cape-super-capf
                               #'lsp-completion-at-point)
                              #'cape-file))))

    (defun coruf-eglot-completions ()
      (setq-local completion-at-point-functions
                  (cons #'tempel-complete
                        (list #'cape-file
                              #'eglot-completion-at-point)))))

#+END_SRC

** Vertico, consult, embark
#+begin_src emacs-lisp
  (use-package vertico
    :straight (vertico
               :type git
               :host github
               :repo "minad/vertico"
               :files (:defaults "extensions/*")
               :includes (vertico-repeat vertico-directory))
    :hook ((rfn-eshadow-update-overlay . vertico-directory-tidy)
           (minibuffer-setup . vertico-repeat-save))
    :init
    (vertico-mode)

    (setq vertico-cycle t)
    (setq enable-recursive-minibuffers nil)

    ;; Use evil in the minibuffer
    (evil-define-key '(insert normal) minibuffer-local-map
      (kbd "RET") 'vertico-exit
      (kbd "C-n") 'vertico-next
      (kbd "C-p") 'vertico-previous)

    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))

    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    (leader-key "r" 'vertico-repeat-select)

    (evil-define-key '(insert normal) vertico-map
      (kbd "DEL") 'vertico-directory-delete-char
      (kbd "M-DEL") 'vertico-directory-delete-word))

  (defun use-orderless-in-minibuffer ()
    (setq-local completion-styles '(orderless basic)))

  (use-package orderless
    :straight t
    :hook (minibuffer-setup . use-orderless-in-minibuffer)
    :init
    ;; Escape spaces with ?\
    (setq orderless-component-separator 'orderless-escapable-split-on-space)

    (defun without-if-bang (pattern _index _total)
      (cond
       ((equal "!" pattern)
        '(orderless-literal . ""))
       ((string-prefix-p "!" pattern)
        `(orderless-without-literal . ,(substring pattern 1)))))

    (setq orderless-style-dispatchers
          '(without-if-bang))

    (setq completion-styles '(basic orderless))

    (setq completion-category-defaults nil
          completion-category-overrides
          '((file (styles basic partial-completion))
            (lsp-capf (styles basic)))))

  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :straight t
    :init
    (savehist-mode))

  ;; Enable richer annotations using the Marginalia package
  (use-package marginalia
    :straight t
    :config
    (marginalia-mode))

  (defun consult-line-evil-history (&rest _)
    "Add latest `consult-line' search pattern to the evil search history ring.
  This only works with orderless and for the first component of the search."
    (when (and (bound-and-true-p evil-mode)
               (eq evil-search-module 'evil-search))
      (let ((pattern (car (orderless-pattern-compiler (car consult--line-history)))))
        (add-to-history 'evil-ex-search-history pattern)
        (setq evil-ex-search-pattern (list pattern t t))
        (setq evil-ex-search-direction 'forward)
        (when evil-ex-search-persistent-highlight
          (evil-ex-search-activate-highlight evil-ex-search-pattern)))))

  (advice-add #'consult-line :after #'consult-line-evil-history)

  (use-package consult
    :straight (consult :type git :host github :repo "minad/consult")
    :config
    (evil-define-key '(insert normal) minibuffer-local-map
      (kbd "C-r") 'consult-history)

    (defun +consult-kill-line-insert-history ()
      (interactive)
      (goto-char (point-max))
      (ignore-errors (call-interactively 'move-beginning-of-line) t)
      (ignore-errors (call-interactively 'kill-line) t)
      (call-interactively 'consult-history))

    (evil-global-set-key 'insert
                         (kbd "C-r") '+consult-kill-line-insert-history)
    (evil-global-set-key 'normal
                         (kbd "C-r") '+consult-kill-line-insert-history)

    (defun +consult-ripgrep-fallback-advice (old-fn &rest args)
      (interactive)
      (if (executable-find "rg")
          (funcall old-fn)
        (consult-grep)))

    (consult-customize
     consult-history :initial nil)

    (advice-add 'consult-ripgrep :around #'+consult-ripgrep-fallback-advice)

    (leader-key
      "."  'find-file-at-point
      "pg"  'consult-ripgrep
      "pl" 'consult-locate
      "b"  'consult-buffer
      "i"  'consult-imenu
      "hh" 'describe-function
      "hv" 'describe-variable
      "m"  'consult-bookmark
      "jm" 'consult-mark
      "jc" 'consult-compile-error
      "y"  'consult-yank-pop
      ":"  'execute-extended-command
      "s"  'consult-line)
    :config
    ;; Do not preview buffers in consult-buffer
    (consult-customize consult-buffer :preview-key '())

    ;; Add eshell as a buffer source
    (defvar eshell-buffer-source
      `(:name     "Eshell Buffer"
                  :narrow   (?e . "Eshell")
                  :hidden   t
                  :category buffer
                  :face     consult-buffer
                  :history  buffer-name-history
                  :state    ,#'consult--buffer-state
                  :items
                  ,(lambda ()
                     (consult--buffer-query :mode 'eshell-mode
                                            :as #'buffer-name)))
      "Eshell buffer candidate source for `consult-buffer'.")
    (add-to-list 'consult-buffer-sources 'eshell-buffer-source 'append)

    ;; Use semicolon as spliter
    (setq consult-async-split-style 'semicolon)

    ;; Add repl buffer source for easier repl creation
    (setq consult-buffer-repls '(("*Python*" . run-python)
                                 ("*nodejs*" . nodejs-repl)
                                 ("*eshell*" . eshell)
                                 ("*SQL: MySQL*" . sql-mysql)))

    (defun open-repl-other-window (key)
      (interactive
       (list (completing-read "Switch to REPLish: "
                              (->> consult-buffer-repls
                                (mapcar 'car))
                              nil
                              t)))
      (call-interactively (alist-get key consult-buffer-repls nil nil 'equal)))

    (defvar repl-buffer-source
      `(:name     "REPLish buffers"
                  :narrow   (?r . "REPL")
                  :hidden   nil
                  :category consult-repl
                  :face     consult-buffer
                  :state    ,#'consult--buffer-state
                  :history  buffer-name-history
                  :action   ,(lambda (key)
                               (funcall (alist-get key consult-buffer-repls)))
                  :items    ,(lambda ()
                               (->> consult-buffer-repls
                                 (mapcar 'car)))
                  "Repl buffer candidate source for `consult-buffer'."))

    (add-to-list 'consult-buffer-sources 'repl-buffer-source 'append)

    ;; Use consult as the completion-in-region in minibuffer
    (add-hook 'minibuffer-mode-hook
              (lambda (&rest _)
                (setq-local completion-in-region-function
                            (lambda (&rest args)
                              (apply (if vertico-mode
                                         #'consult-completion-in-region
                                       #'completion--in-region)
                                     args))))))

  (use-package which-key
    :straight t
    :diminish which-key-mode
    :init
    (which-key-mode))

  (defun find-file-at (file)
    (interactive "Directory: ")
    (let* ((default-directory (file-name-directory
                               (expand-file-name
                                (substitute-in-file-name file)))))
      (call-interactively 'find-file)))

  (defun +magit-there (file)
    "Run magit in directory of FILE."
    (interactive "Directory: ")
    (let ((default-directory (file-name-directory
                              (expand-file-name
                               (substitute-in-file-name file)))))
      (windmove-display-same-window)
      (magit-status default-directory)))

  (use-package embark-consult
    :straight (embark-consult :type git :host github :repo "oantolin/embark"))

  (use-package embark
    :straight (embark :type git :host github :repo "oantolin/embark")
    :after embark-consult
    :config

    (defun embark-act-noquit ()
      "Run action but don't quit the minibuffer afterwards."
      (interactive)
      (let ((embark-quit-after-action nil))
        (embark-act)))

    (evil-define-key '(insert normal) minibuffer-local-map
      (kbd "C-SPC") 'embark-act
      (kbd "C-@") 'embark-act ;; In terminal C-@ -> {C-SPC,C-S-SPC}
      (kbd "C-S-SPC") 'embark-act-noquit
      (kbd "C-<return>") 'embark-export)

    ;; Show Embark actions via which-key
    (setq embark-action-indicator
          (lambda (map)
            (which-key--show-keymap "Embark" map nil nil 'no-paging)
            #'which-key--hide-popup-ignore-command)
          embark-become-indicator embark-action-indicator)

    (define-key embark-file-map "." 'find-file-at)
    (define-key embark-file-map "g" '+magit-there)
    (define-key embark-file-map "G" 'consult-ripgrep)
    (define-key embark-file-map "e" '+eshell-from-path)
    (define-key embark-file-map "E" '+eshell-from-path-other-window)

    (defvar-keymap embark-repls-actions-map
      :doc "Keymap for actions for repls"
      :parent embark-general-map
      "o" #'open-repl-other-window)

    (add-to-list 'embark-keymap-alist '(consult-repl . embark-repls-actions-map)))
#+end_src

** Minibuffer
#+BEGIN_SRC emacs-lisp
  (setq minibuffer-insert-commands '(consult-line
                                     consult-ripgrep
                                     consult-lsp-symbols
                                     consult-eglot-symbols
                                     async-shell-command
                                     project-async-shell-command))

  (defun minibuffer-insert-selection ()
    (when-let* ((_ (member this-command minibuffer-insert-commands))
                (minibuffer-buffer (current-buffer))
                (buffers (buffer-list))
                (last-used-buffer (cadr buffers)))
      (with-current-buffer last-used-buffer
        (when (use-region-p)
          (let ((selection (buffer-substring-no-properties (region-beginning) (region-end))))
            (deactivate-mark)
            (with-current-buffer minibuffer-buffer
              (insert selection)))))))

  (add-hook 'minibuffer-setup-hook 'minibuffer-insert-selection)
#+end_src

* Snippets
** Tempel
#+begin_src emacs-lisp
  (use-package tempel
    :straight t
    :hook (evil-insert-state-exit . tempel-done)
    :config
    (defun tempel-setup-capf ()
      (setq-local completion-at-point-functions
                  (cons #'tempel-complete
                        completion-at-point-functions)))

    (setq tempel-trigger-prefix "!")

    (defun tempel-or-corfu-complete-next ()
      (interactive)
      (if completion-in-region-mode
          (call-interactively 'corfu-complete)
       (call-interactively 'tempel-next)))

    (define-key tempel-map (kbd "TAB") 'tempel-or-corfu-complete-next)
    (define-key tempel-map (kbd "<tab>") 'tempel-or-corfu-complete-next)
    (define-key tempel-map (kbd "<backtab>") 'tempel-previous)
    (define-key tempel-map (kbd "S-TAB") 'tempel-previous)

    (add-hook 'eshell-mode-hook 'tempel-setup-capf)
    (add-hook 'prog-mode-hook 'tempel-setup-capf)
    (add-hook 'text-mode-hook 'tempel-setup-capf))

  (use-package tempel-collection :straight t)
#+end_src

* Project management
#+begin_src emacs-lisp
  (defmacro project-with-directory (force &rest body)
    "Try to set `default-dirctory' by using project.el.

    If FORCE is non nil prompt user for project if not already inside of
    project else use `default-directory'"
    (declare (indent 1) (debug t))
    `(let ((default-directory (or (and (project-current ,force)
                                       (project-root (project-current ,force)))
                                  default-directory)))
       ,@body))

  (defun project-project-root (&optional force)
    (when-let ((project (project-current force)))
      (project-root project)))

  (defun project-find-file-at (file)
    "Run project-find-file in directory of FILE."
    (interactive "Directory: ")
    (let* ((default-directory (file-name-directory
                               (expand-file-name
                                (substitute-in-file-name file)))))
      (project-find-file)))

  ;; https://github.com/minad/vertico/issues/296
  (defvar project-file nil)

  (defun project--read-file-cpd-relative-fix (prompt
                                              all-files &optional predicate
                                              hist mb-default)
    (project--read-file-cpd-relative prompt
                                     all-files
                                     predicate
                                     'project-file
                                     mb-default))
  (use-package project
    :straight (:type built-in)
    :config
    (setq project-vc-extra-root-markers '(".projectile" ".project"))
    (setq project-switch-commands 'project-find-file)
    (setq project-read-file-name-function #'project--read-file-cpd-relative-fix)

    (define-key embark-file-map " " 'project-find-file-at)

    (leader-key
      "SPC" 'project-find-file
      "pp" 'project-switch-project
      "p!" 'project-async-shell-command
      "pc" 'project-compile))
#+end_src

* Terminal
** Get $PATH from bash/zsh profiles
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :straight t
    :config
    (exec-path-from-shell-initialize))
#+end_src

** Eshell
#+begin_src emacs-lisp
  (defun +eshell-name ()
    (let* ((path-part (if (and (bound-and-true-p eshell-project-type-p)
                               (project-project-root))
                          (format "<%s>"
                                  (-> (project-project-root)
                                      file-name-directory
                                      directory-file-name
                                      file-name-nondirectory))
                        (setq-local eshell-project-type-p nil)
                        (abbreviate-file-name default-directory))))
           (format "*eshell %s*" path-part)))

  (defun +eshell-rename ()
    (interactive)
    (when (bound-and-true-p eshell-mode)
      (rename-buffer (generate-new-buffer-name (+eshell-name)
                                               (buffer-name)))))
  (defun +eshell ()
    (let* ((name (+eshell-name))
           (buffer (cond
                    ;; If called from eshell buffer generate new buffer
                    ((bound-and-true-p eshell-mode) (generate-new-buffer name))
                    ;; If eshell buffer exist grab that
                    ((get-buffer name) (get-buffer name))
                    ;; Otherwise generate new buffer
                    (t (generate-new-buffer name)))))
      (with-current-buffer buffer
        (unless (bound-and-true-p eshell-mode)
          (eshell-mode))
      buffer)))

  (defun +eshell-same-window ()
    (interactive)
    (switch-to-buffer (+eshell))
    (+eshell/goto-end-of-prompt))

  (defun +eshell-project ()
    (let* ((default-directory (project-project-root t))
           (eshell-project-type-p t)
           (buffer (+eshell)))
      (with-current-buffer buffer
        (setq-local eshell-project-type-p t)
      buffer)))

  (defun +eshell-other-window ()
    (interactive)
    (switch-to-buffer-other-window (+eshell))
    (+eshell/goto-end-of-prompt))

  (defun +eshell-project-same-window ()
    (interactive)
    (switch-to-buffer (+eshell-project))
    (+eshell/goto-end-of-prompt))

  (defun +eshell-project-other-window ()
    (interactive)
    (switch-to-buffer-other-window (+eshell-project))
    (+eshell/goto-end-of-prompt))

  (defun +eshell-from-path (path)
    (interactive "F")
    (let ((default-directory (file-name-directory
                                (expand-file-name
                                 (substitute-in-file-name path)))))
      (switch-to-buffer (+eshell))
      (+eshell/goto-end-of-prompt)))

  (defun +eshell-from-path-other-window (path)
    (interactive "F")
    (let ((default-directory (file-name-directory
                                (expand-file-name
                                 (substitute-in-file-name path)))))
      (switch-to-buffer-other-window (+eshell))
      (+eshell/goto-end-of-prompt)))

  (defun +eshell/goto-end-of-prompt ()
    "Move cursor to the prompt when switching to insert mode (if point isn't
                                already there)."
    (interactive)
    (goto-char (point-max))
    (evil-append 1))

  (defun +eshell/consult-esh-history-normal ()
    "Move cursor to the end of the buffer before calling counsel-esh-history
                                  and change `state` to insert."
    (interactive)
    (goto-char (point-max))
    (eshell-bol)
    (unwind-protect
        (kill-line)
      (progn
        (evil-append-line 0)
        (consult-history))))

  (defun eshell-after-split (&rest _)
    (when (bound-and-true-p eshell-mode)
      (+eshell)))

  (defun +eshell-previous-prompt-hack ()
    "With prompt as field eshell-previous-prompt sets cursor at the beggining of the line and not at prompt begin"
    (interactive)
    (call-interactively 'eshell-previous-prompt)
    (when (= (current-column) 0)
      (call-interactively 'eshell-next-prompt)))

  (defun eshell-mode-configuration ()
    (push 'eshell-tramp eshell-modules-list)

    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    (eshell-hist-initialize)

    (evil-define-key 'normal 'local
      "I" (lambda () (interactive) (eshell-bol) (evil-insert 1))
      (kbd "S") (lambda () (interactive) (eshell-bol) (kill-line) (evil-append 1))
      (kbd "C-p") '+eshell-previous-prompt-hack
      (kbd "C-n") 'eshell-next-prompt
      (kbd "C-r") '+eshell/consult-esh-history-normal
      (kbd "<return>") '+eshell/goto-end-of-prompt
      "q" (lambda () (interactive) (kill-buffer)))

    (evil-define-key 'visual 'local
      (kbd "<return>") (lambda () (interactive) (progn (eshell-send-input t) (evil-normal-state)))))

  (defun +eshell-make-field ()
    "Make text in front of the point a field, useful for prompts."
    (let ((inhibit-read-only t))
      (add-text-properties
       (line-beginning-position) (point)
       (list 'field t
             'rear-nonsticky t))))

  (defun +eshell-global-history-init ()
    "Share the eshell history ring between the eshell buffers.
  Addice add this :after `eshell-hist-initialize`"
    (or (boundp 'eshell-global-history-ring)
        (setq eshell-global-history-ring (ring-copy eshell-history-ring)))
    (setq eshell-history-ring eshell-global-history-ring))

  (use-package eshell
    :hook ((eshell-first-time-mode . eshell-mode-configuration)
           (eshell-directory-change . +eshell-rename)
           (eshell-after-prompt . +eshell-make-field)
           (eshell-mode . (lambda ()
                            ;; imenu support for eshell
                            (setq-local imenu-generic-expression '(("$ " " $ \\(.*\\)" 1))))))
    :init
    (setq eshell-hist-ignoredups t
          eshell-save-history-on-exit t
          eshell-destroy-buffer-when-process-dies t)

    (setenv "PAGER" "cat")

    ;; TODO remove the follwing if not needed
    ;;(advice-add '+emacs/split-follow-window-horizontally :after #'eshell-after-split)
    ;;(advice-add '+emacs/split-follow-window-vertically :after #'eshell-after-split)
    (advice-add 'eshell-hist-initialize :after #'+eshell-global-history-init)

    (leader-key "e" '+eshell-same-window)
    (leader-key "E" '+eshell-other-window)
    (leader-key "pe" '+eshell-project-same-window)
    (leader-key "pE" '+eshell-project-other-window))

  (use-package eshell-syntax-highlighting
    :straight t ;; Install if not already installed.
    :config
    ;; Enable in all Eshell buffers.
    (eshell-syntax-highlighting-global-mode +1))
#+end_src

** Eshell functions
#+begin_src emacs-lisp
  (defun eshell/ff (&rest args)
    (apply #'find-file args))

  (defun eshell/awswhoami (&rest args)
    (let ((profile (getenv "AWS_PROFILE")))
      (message (if (null profile) "default" profile))))

  (defun slurp (f)
    (with-temp-buffer
      (insert-file-contents f)
      (buffer-substring-no-properties
       (point-min)
       (point-max))))

  (defun eshell/awsprofile (&rest args)
    (require 'seq)
    (let* ((matches (seq-filter (apply-partially 'string-match "\^\[*.\]\$")
                                (split-string (slurp "~/.aws/credentials"))))
           (trim (seq-map (lambda (x) (string-trim x "\\[" "\\]")) matches))
           (choice (ivy-read "AWS Profile: " trim)))
      (setenv "AWS_PROFILE" choice)))
#+end_src

** Proc-hist
#+begin_src  emacs-lisp
  (use-package proc-hist
    :straight (proc-hist :type git :host github :repo "svaante/proc-hist")
    :config
    (proc-hist-mode)

    (defvar-keymap embark-proc-hist-actions-map
      :doc "Proc hist actions"
      :parent embark-general-map
      "k" #'proc-hist-kill
      "r" #'proc-hist-rerun
      "R" #'proc-hist-rerun-as
      "w" #'proc-hist-copy-as-kill-command)

      (add-to-list 'embark-keymap-alist '(proc-hist . embark-proc-hist-actions-map))

    (leader-key
      "d" 'proc-hist-dwim))
#+end_src

** Shell-mode
#+begin_src emacs-lisp
  (defun kill-on-no-process ()
    (interactive)
    (if (null (get-buffer-process (current-buffer)))
        (kill-buffer)
      (quit-window)))

  (use-package shell
    :straight (:type built-in)
    :config
    (setq evil-normal-state-modes (append evil-normal-state-modes '(shell-mode)))
    (evil-define-key 'normal shell-mode-map "q" 'kill-on-no-process)

    (define-key embark-file-map "!" 'async-shell-command)
    (setq async-shell-command-buffer 'rename-buffer)
    (setq shell-command-prompt-show-cwd t)

    (leader-key
      "!" 'async-shell-command))
#+END_SRC

* Misc
** wgrep
Change stuff in the grep buffer
#+begin_src emacs-lisp
  (use-package wgrep :straight t)
#+end_src

** ediff
#+begin_src emacs-lisp
  (use-package ediff
    :straight (:type built-in)
    :config
    (setq ediff-window-setup-function 'ediff-setup-windows-plain))
#+end_src

** Writing
#+begin_src emacs-lisp
  (defun +ispell-toogle-english-swedish-dictonary ()
    "Toggle `Ispell´ dictionary between English and Swedish."
    (interactive)
    (when (bound-and-true-p flyspell-mode)
      (cond
       ((string-equal ispell-local-dictionary flyspell-default-dictionary)
        (ispell-change-dictionary "swedish"))
       ((string-equal ispell-local-dictionary "swedish")
        (ispell-change-dictionary flyspell-default-dictionary))
       (t
        (ispell-change-dictionary flyspell-default-dictionary)))))

  (use-package flyspell
    :straight t
    ;;inside git commit and markdown
    :hook ((git-commit-mode org-mode markdown-mode) . flyspell-mode)
    :config
    (setq flyspell-default-dictionary "english")

    (defun +flyspell-programing-english ()
      (interactive)
      (ispell-change-dictionary flyspell-default-dictionary)
      (flyspell-prog-mode))

    (leader-key
      "ff" '+ispell-toogle-english-swedish-dictonary
      "fp" '+flyspell-programing-english))

  (use-package define-word
    :straight t
    :config
    (leader-key "fd"
      'define-word-at-point))
#+end_src

** Dedicated windows
#+begin_src emacs-lisp
  (defun toggle-window-dedicated ()
    "Toggle window dedicated"
    (interactive)
    (set-window-dedicated-p (selected-window)
                            (not (window-dedicated-p))))

  (leader-key "wl" 'toggle-window-dedicated)

  (defun kill-dedicated-windows ()
    "Kill all dedicated windows"
    (interactive)
    (seq-do (lambda (window)
              (when (window-dedicated-p window)
                (quit-window nil window)))
            (window-list)))

  (leader-key "wk" 'kill-dedicated-windows)
#+END_SRC

** Scratch
#+begin_src emacs-lisp
  ;; Eval code lisp in the *scratch* buffer
  (define-key lisp-interaction-mode-map (kbd "C-c C-c") 'eval-buffer)
#+end_src

** Useful functions
#+begin_src emacs-lisp
  (defun +zoom-window ()
    (interactive)
    (if (and (= 1 (count-windows))
             (bound-and-true-p zoomed-window-configuration))
        (let ((buffer (current-buffer)))
          (set-window-configuration zoomed-window-configuration)
          (switch-to-buffer buffer))
      (setq-local zoomed-window-configuration (current-window-configuration))
      (delete-other-windows)))

  (define-key evil-normal-state-map "\C-wo" '+zoom-window)
  (define-key evil-emacs-state-map "\C-wo" '+zoom-window)
  (define-key evil-visual-state-map "\C-wo" '+zoom-window)

  ;; source: http://steve.yegge.googlepages.com/my-dot-emacs-file
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive (list (read-string "New name: " (buffer-name (current-buffer)))))
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (progn
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil))))))

  (defvar load-one-theme-hist nil)
  (defun load-one-theme (theme)
    "Disable each loaded theme and load theme THEME"
    (interactive
     (list
      (intern (completing-read "Load custom theme: "
                               (mapcar #'symbol-name
                                       (custom-available-themes))
                               nil
                               nil
                               nil
                               'load-one-theme-hist))))
    (dolist (theme custom-enabled-themes)
      (disable-theme theme))
    (load-theme theme t))

  (defun load-last-theme ()
    (when (and consult--theme-history)
      (load-one-theme (intern (car consult--theme-history)))))

  (eval-after-load "savehist"
    (add-hook 'savehist-mode-hook 'load-last-theme))
#+end_src


* Programming
** Progn mode
#+begin_src emacs-lisp
  (use-package prog-mode
    :straight (:type built-in)
    :config
    (evil-define-key 'normal prog-mode-map "gr" 'xref-find-references)
    (evil-define-key 'normal prog-mode-map "gD" 'xref-find-definitions-other-window)

    (setq xref-prompt-for-identifier
          '(not xref-find-definitions
                xref-find-definitions-other-window
                xref-find-definitions-other-frame
                xref-find-references)))
#+end_src

** Flycheck
#+begin_src emacs-lisp
  (use-package flycheck
    :straight t)
#+end_src

** 80 Columns
#+begin_src emacs-lisp
  (use-package display-fill-column-indicator
    :straight (:type built-in)
    :hook (prog-mode-hook . display-fill-column-indicator-mode)
    :config
    (setq display-fill-column-indicator-column 80))
#+end_src

** LSP
#+begin_src emacs-lisp
  (use-package lsp-snippet-tempel
    :straight (lsp-snippet-tempel :type git
                                  :host github
                                  :repo "svaante/lsp-snippet")
    :config
    (lsp-snippet-tempel-eglot-init))

  (use-package lsp-mode
    :disabled
    :straight t
    :hook (prog-mode . (lambda ()
                         (unless (derived-mode-p 'clojure-mode
                                                 'emacs-lisp-mode
                                                 'lisp-mode
                                                 'snippet-mode)
                           (lsp-deferred))))
    :hook (lsp-mode . (lambda ()
                        (setq-local evil-lookup-func 'lsp-describe-thing-at-point)))
    :config
    (setq lsp-file-watch-threshold 1000)
    (setq lsp-headerline-breadcrumb-enable nil)
    (setq lsp-modeline-code-actions-enable nil)
    (setq lsp-modeline-diagnostics-enable nil)
    (setq lsp-lens-enable nil)
    (setq lsp-completion-provider :none)
    (setq lsp-completion-enable nil)

    ;; enable lsp-mode inside of org babel edit src blocks
    (defun org-babel-edit-prep:python (babel-info)
      (setq-local buffer-file-name (->> babel-info caddr (alist-get :tangle))))

    ;; c mode configurations
    (setq lsp-clients-clangd-args
          '("-j=2"
            "--background-index"
            "--clang-tidy"
            "--completion-style=bundled"
            "--pch-storage=memory"
            "--header-insertion=never"
            "--header-insertion-decorators=0"))

    (leader-key
      "lr" 'lsp-rename
      "lf" 'lsp-format-buffer))

  (use-package consult-lsp
    :straight t
    :config
    (define-key lsp-mode-map [remap xref-find-apropos] #'consult-lsp-symbols)
    (leader-key
      "ls" 'consult-lsp-symbols))
#+end_src

** Eglot
#+begin_src emacs-lisp
  (use-package eglot
    :straight (:type built-in)
    :hook ((c-mode . eglot-ensure)
           (python-mode . eglot-ensure))
    :config
    (leader-key "lr" 'eglot-rename)
    (leader-key "lf" 'eglot-format-buffer))

  (use-package consult-eglot
    :straight t
    :config
    (leader-key "ls" 'consult-eglot-symbols))
#+END_SRC


** Emacs lisp
#+begin_src emacs-lisp
  ;; Stolen from http://www.sugarshark.com/elisp/init/lisp.el.html
  (defun describe-elisp-thing-at-point ()
    "Show the documentation of the Elisp function and variable near point.
          This checks in turn:
          -- for a function name where point is
          -- for a variable name where point is
          -- for a surrounding function call
          "
    (interactive)
    (let (sym)
      ;; sigh, function-at-point is too clever.  we want only the first half.
      (cond ((setq sym (ignore-errors
                         (with-syntax-table emacs-lisp-mode-syntax-table
                           (save-excursion
                             (or (not (zerop (skip-syntax-backward "_w")))
                                 (eq (char-syntax (char-after (point))) ?w)
                                 (eq (char-syntax (char-after (point))) ?_)
                                 (forward-sexp -1))
                             (skip-chars-forward "`'")
                             (let ((obj (read (current-buffer))))
                               (and (symbolp obj) (fboundp obj) obj))))))
             (describe-function sym))
            ((setq sym (variable-at-point)) (describe-variable sym))
            ;; now let it operate fully -- i.e. also check the
            ;; surrounding sexp for a function call.
            ((setq sym (function-at-point)) (describe-function sym)))))

  (use-package elisp-mode
    :straight (:type built-in)
    :config
    (seq-do
     (lambda (mode-map)
       (evil-define-key 'normal mode-map
         (kbd "K")
         'describe-elisp-thing-at-point)
       (evil-define-key '(normal insert) mode-map
         (kbd "C-c C-e") 'eval-defun)
       (evil-define-key '(normal insert) mode-map
         (kbd "C-c C-c") 'eval-buffer)
       (evil-define-key 'visual mode-map
         (kbd "C-c C-c") 'eval-region))
     (list emacs-lisp-mode-map lisp-interaction-mode-map)))
#+end_src

** Readable data files
#+begin_src emacs-lisp
  (use-package yaml-mode :straight t)

  (use-package json-mode :straight t)

  (use-package csv-mode
    :straight t
    :hook ((csv-mode . csv-align-mode)
           (csv-mode . csv-highlight))
    :config

    (defun csv-highlight (&optional separator)
      (interactive (list (when current-prefix-arg (read-char "Separator: "))))
      (font-lock-mode 1)
      (let* ((separator (or separator ?\,))
             (n (count-matches (string separator) (point-at-bol) (point-at-eol)))
             (colors (cl-loop for i from 0 to 1.0 by (/ 2.0 n)
                              collect (apply #'color-rgb-to-hex
                                             (color-hsl-to-rgb i 0.3 0.5)))))
        (cl-loop for i from 2 to n by 2
                 for c in colors
                 for r = (format "^\\([^%c\n]+%c\\)\\{%d\\}" separator separator i)
                 do (font-lock-add-keywords nil `((,r (1 '(face (:foreground ,c))))))))))
#+end_src

** Go
#+begin_src emacs-lisp
  (use-package go-mode :straight t)
#+end_src

** Clojure
#+begin_src emacs-lisp
  (use-package clojure-mode :straight t :defer t)
  (use-package cider :straight t :defer t)
#+end_src

** C
#+begin_src emacs-lisp
  (use-package cc-mode
    :straight (:type built-in)
    :config
    (setq c-basic-offset 4))
#+end_src

** Javascript
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (setq js-indent-level 2))

  (use-package web-mode
    :straight t
    :defer t
    :custom
    (web-mode-markup-indent-offset 2)
    (web-mode-css-indent-offset 2)
    (web-mode-code-indent-offset 2)
    :config
    (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
    (add-to-list 'auto-mode-alist '("\\.jsx?$" . web-mode)))

  (use-package add-node-modules-path :straight t)

  (use-package nodejs-repl
    :straight t
    :config
    ;; https://github.com/abicky/nodejs-repl.el/issues/37
    (defun +nodejs-repl-remove-broken-filter ()
      (remove-hook 'comint-output-filter-functions 'nodejs-repl--delete-prompt t))

    (add-hook 'nodejs-repl-mode-hook #'+nodejs-repl-remove-broken-filter))
#+end_src

** Python
#+begin_src emacs-lisp
  (use-package lsp-pyright :straight t)

  (defun +inferior-python-mode-init ()
    (advice-add 'python-shell-completion-at-point :around 'cape-wrap-purify)
    (advice-add 'python-shell-completion-at-point :around 'cape-wrap-noninterruptible)
    (setq-local completion-styles '(basic)))

  (use-package python
    :after cape
    :hook ((inferior-python-mode . +inferior-python-mode-init)
           (python-mode . hs-minor-mode))
    :config
    (defun +python-shell-send-dwm ()
      (interactive)
      (or (python-shell-get-process) (run-python))
      (if (use-region-p)
          (call-interactively 'python-shell-send-region)
        (call-interactively 'python-shell-send-buffer)))

    (setq python-shell-interpreter "ipython3"
          python-shell-interpreter-args "-i --simple-prompt"
          python-shell-completion-native-enable nil)

    (define-key python-mode-map (kbd "C-c C-c") '+python-shell-send-dwm))
#+end_src

** Typescript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :straight t
    :config
    (setq-default typescript-indent-level 2))
#+end_src

** Rust
#+begin_src emacs-lisp
  (use-package rustic
    :disabled
    :straight t
    :config
    ;; Remove auto formating which caused isses with trying to save all buffers
    (advice-remove 'save-some-buffers 'rustic-save-some-buffers-advice)

    ;; Use rustic compilation mode stuff outside of rustic-compilation mode
    (add-hook 'compilation-filter-hook #'rustic-insert-errno-button nil)
    (add-to-list 'compilation-error-regexp-alist-alist
                 (cons 'rustic-error rustic-compilation-error))
    (add-to-list 'compilation-error-regexp-alist-alist
                 (cons 'rustic-warning rustic-compilation-warning))
    (add-to-list 'compilation-error-regexp-alist-alist
                 (cons 'rustic-info rustic-compilation-info))
    (add-to-list 'compilation-error-regexp-alist-alist
                 (cons 'rustic-panic rustic-compilation-panic))
    (add-to-list 'compilation-error-regexp-alist 'rustic-error)
    (add-to-list 'compilation-error-regexp-alist 'rustic-warning)
    (add-to-list 'compilation-error-regexp-alist 'rustic-info)
    (add-to-list 'compilation-error-regexp-alist 'rustic-panic))
#+end_src

** Godot
#+begin_src emacs-lisp
  (use-package gdscript-mode
    :straight t
    :config
    (setq gdscript-use-tab-indents nil)
    (setq gdscript-indent-offset 4))
#+end_src

** Devdocs
#+begin_src  emacs-lisp
  (defun devdocs-lookup-ask-docs ()
    (interactive)
    (devdocs-lookup t))

  (use-package devdocs
    :straight t
    :config
    (leader-key "k" 'devdocs-lookup)
    (leader-key "K" 'devdocs-lookup-ask-docs))

  (use-package eldoc
    :straight (:type built-in)
    :config
    (setq eldoc-echo-area-use-multiline-p 1))
#+end_src

** Compilation
#+begin_src emacs-lisp
  (use-package xterm-color
    :straight t
    :config
    (setq compilation-environment '("TERM=xterm-256color"))

    (defun xterm-color-advice-compilation-filter (f proc string)
      (funcall f proc (xterm-color-filter string)))

    (advice-add 'compilation-filter :around #'xterm-color-advice-compilation-filter))

  (use-package compile
    :straight (:type built-in)
    :config
    ;; Use last history as the compile command
    (setq compile-command (or (car-safe compile-history) ""))
    ;; Always scroll
    (setq compilation-scroll-output t)
    ;; Just save me the keystrokes
    (setq compilation-ask-about-save nil)

    (evil-define-key 'normal compilation-minor-mode-map
      (kbd "<tab>") 'compilation-next-file
      (kbd "<backtab>") 'compilation-previous-file))
#+end_src

** Debugging
*** C
#+begin_src emacs-lisp
  (defun gud-kill-buffers ()
    (interactive)
    (seq-do
     (lambda (buffer)
       (when (string-match-p "\\\*gud-.*\\\*" (or (buffer-name buffer) ""))
         (kill-buffer buffer)))
     (buffer-list)))

  (defvar gud-co--process-command nil)

  (defun gud-co-set-process-command (command)
    (interactive (list
                  (read-shell-command "gud-co process: "
                                      gud-co--process-command)))
    (setq gud-co--process-command command))

  (defun gud-start-co--command ()
    (interactive)
    (when (and gud-co--process-command
               (not (string-empty-p gud-co--process-command)))
      (let ((args (split-string-shell-command gud-co--process-command)))
        (apply
         'make-comint
         `(,(format "gud-co-%s" gud-co--process-command)
           ,(car args)
           nil . ,(cdr args))))))

  (defvar +gud-basic-call-hist nil)

  (defun +gud-basic-call (command)
    (interactive (list (read-string "gud basic call: "
                                    (car +gud-basic-call-hist)
                                    '+gud-basic-call-hist)))
    (gud-basic-call command))

  (defun +gdb-project ()
    (interactive)
    (gud-start-co--command)
    (let ((buf (current-buffer)))
      (project-with-directory t
        (call-interactively 'gdb)
        (switch-to-buffer buf))))

  (defun gud-open-comint-buffer ()
    (interactive)
    (let ((gud-buffer (seq-find (lambda (buffer)
                                  (with-current-buffer buffer
                                    (bound-and-true-p gud-mode)))
                                (buffer-list))))
      (switch-to-buffer gud-buffer)))

  (defhydra hydra-gdb (:exit nil :foreign-keys run :hint nil)
    "
    _o_pen (_O_: gdb)     _R_un        _b_reak      _n_ext (_N_: inst)
    _K_ill  ^ ^           _c_ontinue   _t_break     _s_tep (_S_: inst)
    _C_all  ^ ^           ^ ^          _r_emove     _f_inish
    set co-_p_rocess ^ ^  ^ ^          ^ ^          _u_ntil"
    ("o" +gdb-project)
    ("O" gdb)
    ("K" gud-kill-buffers :exit t)
    ("C" +gud-basic-call)
    ("p" gud-co-set-process-command)
    ("R" gud-run)
    ("c" gud-cont)
    ("b" gud-break)
    ("t" gud-tbreak)
    ("r" gud-remove)
    ("n" gud-next)
    ("N" gud-nexti)
    ("s" gud-step)
    ("S" gud-stepi)
    ("f" gud-finish)
    ("u" gud-until)
    ("!" gud-open-comint-buffer)
    ("q" ignore :exit t)
    ("C-g" ignore :exit t))

    ;;(general-define-key
    ;; :prefix "SPC"
    ;; :states 'normal
    ;; :keymaps 'c-mode-map
    ;; "pd" 'hydra-gdb/body)
#+end_src
*** DAP
#+begin_src emacs-lisp
  (use-package dap-mode
    :straight (dap-mode :type git
                        :host github
                        :repo "mrsch/dap-mode"
                        :branch "feat/cortex-debug")
    :hook ((dap-stopped . (lambda (&rest _) (dap-hydra))))
    :config
    (require 'dap-cortex)

    (dap-register-debug-template
     "Cortex F4 debug"
     (list :type "cortex-debug"
           :runToEntryPoint "main"
           :executable nil
           :servertype "jlink"
           :cwd "${workspaceFolder}"
           :device "STM32F405VG"))

    (require 'dap-ui)
    (set-face-attribute 'dap-ui-marker-face nil :inherit 'region)
    (set-face-attribute 'dap-ui-pending-breakpoint-face nil :inherit 'underline)
    (set-face-attribute 'dap-ui-verified-breakpoint-face nil :inherit 'underline)

    (setq dap-auto-show-output nil)
    (setq dap-auto-configure-features nil)

    (leader-key "pd" 'dap-hydra))
#+end_src
* Applications
** Dired
#+begin_src emacs-lisp
  (use-package dired
    :straight (:type built-in)
    :hook (dired-mode . auto-revert-mode)
    :config
    ;; If two dired opened use other dired default-directory as
    ;; base target
    (setq dired-dwim-target t)

    (defun dired-here-other-window ()
      (interactive)
      (dired-other-window default-directory))

    (defun dired-here ()
      (interactive)
      (dired default-directory))

    (leader-key "ad" 'dired-here
                "aD" 'dired-here-other-window))

  (use-package diredfl
    :straight t
    :hook (dired-mode . diredfl-mode))

  (use-package dired-subtree
    :straight t)
#+end_src

** Magit
#+begin_src emacs-lisp
  (use-package magit
    :straight t
    :config
    (setq evil-insert-state-modes (append evil-insert-state-modes '(git-commit-mode)))

    (defun magit-status-here-and-center ()
      (interactive)
      (magit-status-here)
      (recenter))

    ;; Fix for slow magit
    ;; https://github.com/magit/magit/issues/2982#issuecomment-1081204026
    (defun +magit-rev-format (format &optional rev args)
      (let ((str (magit-git-string "log" "-1" "--no-patch"
                                   (concat "--format=" format) args
                                   (if rev (concat rev "^{commit}") "HEAD") "--")))
        (unless (string-equal str "")
          str)))
    (advice-add 'magit-rev-format :override '+magit-rev-format)

    ;; Don't let magit close windows
    (setq magit-bury-buffer-function 'bury-buffer)

    (leader-key "gg" 'magit-status-here-and-center)
    (leader-key "g." 'magit-find-file)
    (leader-key "gd" 'magit-diff)
    (leader-key "gb" 'magit-blame)
    (leader-key "gl" 'magit-log)
    (leader-key "gc" 'magit-checkout)
    (leader-key "gf" 'magit-fetch-all)
    (leader-key "gf" 'magit-log-buffer-file))
#+end_src

** Tramp
#+begin_src emacs-lisp
  (use-package tramp
    :init
    (setq tramp-default-method "ssh"))
#+end_src

** Proced/top
#+BEGIN_SRC emacs-lisp
  (use-package proced
    :straight (:type built-in)
    :config
    (setq proced-enable-color-flag t)

    (defun eshell/top (&rest args)
      (proced))

    (leader-key "ap" 'proced))
#+END_SRC

** Postman
#+begin_src emacs-lisp
  (use-package restclient
    :straight t
    :config
    (setq restclient-buffer-name "*restclient*")

    (defun create-restclient-mode-buffer ()
      (interactive)
      (let ((buffer-exist (get-buffer restclient-buffer-name)))
        (switch-to-buffer-other-window restclient-buffer-name)
        (unless buffer-exist
          (with-current-buffer (get-buffer restclient-buffer-name)
            (unless (bound-and-true-p restclient-mode)
              (progn
                (restclient-mode)
                (insert
                 "Welcome to restclient-mode!\n"
                 "Execute with: C-c C-C\n"
                 "\n"
                 "POST https://httpbin.org/post\n"
                 "Content-Type: application/json\n"
                 "{\n"
                 "   \"key\": \"value\"\n"
                 "}\n")))))
      (goto-char (point-max))
      (evil-insert-state)))

    (defun restclient-buffer-quit ()
      (interactive)
      (delete-windows-on restclient-buffer-name)
      (bury-buffer restclient-buffer-name))

    (evil-define-key 'normal restclient-mode-map
      "q" 'restclient-buffer-quit)

    (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode))

    (leader-key "ah" 'create-restclient-mode-buffer))
#+end_src

** Calc
#+begin_src emacs-lisp
  (use-package literate-calc-mode
    :straight t
    :config
    (setq literate-calc-buffer-name "*literate-calc*")
    (setq literate-calc-mode-idle-time 0.1)

    (defun create-literate-calc-mode-buffer ()
      (interactive)
      (let* ((buffer-exist (get-buffer literate-calc-buffer-name))
             (window-exist (and buffer-exist (get-buffer-window buffer-exist))))
        (if window-exist
            (select-window window-exist)
          (switch-to-buffer-other-window literate-calc-buffer-name)
          (unless buffer-exist
            (with-current-buffer (get-buffer literate-calc-buffer-name)
              (unless (bound-and-true-p literate-calc-mode)
                (progn
                  (literate-calc-mode)
                  (insert
                   "Welcome to literate-calc-mode!\n"
                   "\n"
                   "= "))))))
        (goto-char (point-max))
        (evil-insert-state)))

    (defun literate-calc-buffer-quit ()
      (interactive)
      (delete-windows-on literate-calc-buffer-name)
      (bury-buffer literate-calc-buffer-name))

    (evil-define-key 'normal literate-calc-mode-map
      "q" 'literate-calc-buffer-quit)

    (leader-key "ac"
      'create-literate-calc-mode-buffer))
#+end_src

** Jupyter notebooks
#+begin_src emacs-lisp
  (use-package ein
    :straight t
    :config
    (setq ein:polymode t))
#+end_src

** Elfeed
#+begin_src emacs-lisp
  (defun elfeed-open-and-refresh ()
    (interactive)
    (elfeed)
    (elfeed-update))

  (use-package elfeed
    :straight t
    :config
    (leader-key "ar" 'elfeed-open-and-refresh)
    (setq elfeed-feeds
          '(("https://lithub.com/feed/" kultur)
            ("https://hnrss.org/newest?points=50" tech)
            ("https://us-east1-ml-feeds.cloudfunctions.net/arxiv-ml-reviews" ml)
            ("http://api.sr.se/api/rss/channel/83?format=1" nyheter)))

    (evil-define-key 'normal elfeed-show-mode-map
      "p" 'elfeed-show-prev
      "n" 'elfeed-show-next))
#+end_src

** Email
*** Gnus
#+begin_src emacs-lisp
  (use-package gnus
    :config
    (setq epa-pinentry-mode 'loopback))
#+end_src

** Chatgpt
#+begin_src emacs-lisp
  (use-package gptel
    :straight (gptel :type git :host github :repo "karthink/gptel")
    :config
    (define-key gptel-mode-map (kbd "C-c C-c") 'gptel-send)
    (when (file-exists-p (locate-user-emacs-file "gpt-api-key.el"))
      ;; (setq gptel-api-key "key")
      (load-file (locate-user-emacs-file "gpt-api-key.el")))
    (leader-key "aa" 'gptel))
#+end_src
